<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Jogo Zumbi - Versão Corrigida</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#070607;overflow:hidden;font-family:Inter,Arial}
    #app{width:100%;height:100%;position:relative}
    canvas{display:block}
    #ui{position:absolute;left:10px;bottom:12px;z-index:20;color:#eee}
    .btn{background:rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;margin-right:6px;border:1px solid rgba(255,255,255,0.03);color:#fff;cursor:pointer}
    #fireBtn{position:absolute;right:18px;bottom:70px;width:86px;height:86px;border-radius:50%;z-index:30;background:rgba(160,20,20,0.18);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:800}
    #joystick{position:absolute;left:12px;bottom:80px;width:120px;height:120px;border-radius:50%;z-index:30;touch-action:none}
    #loading{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:50;color:#fff;background:rgba(0,0,0,0.5);padding:18px;border-radius:10px;font-size:16px}
    #errors{position:absolute;left:10px;top:10px;z-index:60;color:#ff7766;max-width:40%;font-size:14px;text-shadow:1px 1px #000;white-space:pre-wrap}
    @media(max-width:720px){ #errors{max-width:80%} }
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="loading">Carregando recursos... <span id="loadPerc">0%</span></div>
  <div id="errors"></div>

  <div id="ui">
    <div id="fps">FPS: --</div>
    <div style="margin-top:6px;">
      <button id="btnSpawn" class="btn">Spawn Zumbi</button>
      <button id="btnShadows" class="btn">Sombras: ON</button>
      <button id="btnDebug" class="btn">Debug</button>
    </div>
  </div>

  <div id="joystick" aria-hidden="true"></div>
  <div id="fireBtn" aria-hidden="true">ATIRAR</div>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/loaders/FBXLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/loaders/MTLLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/loaders/ColladaLoader.js"></script>

<script>
/* ========= CONFIG - nomes exatos que você informou ========= */
const FILES = {
  gunOBJ: 'Gun.obj',
  gunMTL: 'Gun.mtl',
  gunDAE: 'Gun.dae',
  gunPNG: 'Gun.png',
  ground: 'Sample.png',
  fbxIdle: 'idle.fbx',
  fbxRun: 'run.fbx',
  fbxJump: 'jump.fbx'
};
/* ========================================================== */

const app = document.getElementById('app');
const loadingEl = document.getElementById('loading');
const loadPerc = document.getElementById('loadPerc');
const errorsEl = document.getElementById('errors');

// Loading manager robusto
const manager = new THREE.LoadingManager();
manager.onStart = (url, loaded, total) => { loadPerc.innerText = '0%'; };
manager.onProgress = (url, loaded, total) => {
  const perc = Math.round((loaded/total)*100);
  loadPerc.innerText = perc + '%';
};
manager.onLoad = () => { setTimeout(()=> loadingEl.style.display='none', 300); };
manager.onError = (url) => { logError('Erro ao carregar: ' + url); };

// THREE loaders com manager
const fbxLoader = new THREE.FBXLoader(manager);
const objLoader = new THREE.OBJLoader(manager);
const mtlLoader = new THREE.MTLLoader(manager);
const daeLoader = new THREE.ColladaLoader(manager);
const texLoader = new THREE.TextureLoader(manager);

// scène globals
let scene, camera, renderer, clock;
let activeMixers = [];
let gun = null;
let zombieTemplate = { mesh: null, animations: {} }; // sempre definido
const zombies = {}; let zcount = 0;
const player = { pos: new THREE.Vector3(0,1.2,4), speed: 4.5, onGround: true };
const keys = { w:false,a:false,s:false,d:false };

init();
animate();

function logError(msg){
  console.error(msg);
  errorsEl.innerText += msg + '\n';
}

/* ========== INIT ========== */
function init(){
  if (!THREE.WEBGL.isWebGLAvailable()){
    document.body.innerHTML = '<div style="color:#fff;padding:30px">Seu navegador não suporta WebGL.</div>';
    return;
  }

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x07060a);
  scene.fog = new THREE.FogExp2(0x07060a, 0.0035);

  camera = new THREE.PerspectiveCamera(62, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,1.6,6);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  app.appendChild(renderer.domElement);

  clock = new THREE.Clock();

  // lights
  const hemi = new THREE.HemisphereLight(0x99aaff, 0x120a10, 0.55); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xfff3d8, 1.0); dir.position.set(8,12,6); dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048); dir.shadow.camera.left=-20;dir.shadow.camera.right=20;dir.shadow.camera.top=20;dir.shadow.camera.bottom=-20;
  scene.add(dir);
  const rim = new THREE.DirectionalLight(0x88b4ff, 0.25); rim.position.set(-10,8,-6); scene.add(rim);
  scene.add(new THREE.PointLight(0x88aaff,0.08,30)); scene.add(new THREE.PointLight(0xffddcc,0.06,30));

  // ground (tenta carregar Sample.png)
  texLoader.load(FILES.ground, tex => {
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(60,60);
    const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 1 });
    const geo = new THREE.PlaneGeometry(400,400);
    const floor = new THREE.Mesh(geo, mat); floor.rotation.x = -Math.PI/2; floor.receiveShadow=true;
    scene.add(floor);
  }, undefined, err => {
    logError(`Falha ao carregar ${FILES.ground} — usando floor fallback.`);
    const geo = new THREE.PlaneGeometry(400,400);
    const floor = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:0x111114}));
    floor.rotation.x = -Math.PI/2; floor.receiveShadow=true; scene.add(floor);
  });

  // sky/backdrop
  const sky = new THREE.Mesh(new THREE.SphereGeometry(300,32,32), new THREE.MeshBasicMaterial({color:0x050406, side:THREE.BackSide}));
  scene.add(sky);

  // carrega assets (gun + zumbis)
  loadGun();            // MTL/OBJ -> OBJ -> DAE fallback
  loadZombieAssets();   // usa idle.fbx/run.fbx/jump.fbx

  // spawn iniciais (sempre colocamos placeholders se nada carregou)
  setTimeout(()=> { spawnZombie(); spawnZombie(); }, 700);

  // UI
  document.getElementById('btnSpawn').addEventListener('click', ()=> spawnZombie());
  document.getElementById('btnShadows').addEventListener('click', toggleShadows);
  document.getElementById('btnDebug').addEventListener('click', toggleDebug);
  document.getElementById('fireBtn').addEventListener('pointerdown', spawnMuzzleFlash);

  setupJoystick();
  window.addEventListener('resize', onResize);
  window.addEventListener('keydown', onKeyDown); window.addEventListener('keyup', onKeyUp);

  // safety: garante load desapareça se algum loader travar
  setTimeout(()=> { loadingEl.style.display='none'; }, 6000);
}

/* ========== GUN LOADER ========== */
function loadGun(){
  // tenta MTL+OBJ
  mtlLoader.load(FILES.gunMTL, materials => {
    materials.preload();
    objLoader.setMaterials(materials);
    objLoader.load(FILES.gunOBJ, obj => finalizeGun(obj), undefined, err => {
      console.warn('OBJ com MTL falhou:', err);
      // tenta só OBJ
      objLoader.load(FILES.gunOBJ, obj2 => finalizeGun(obj2), undefined, err2 => {
        console.warn('OBJ simples falhou:', err2);
        // tenta DAE (Gun.dae)
        daeLoader.load(FILES.gunDAE, collada => {
          if (collada && collada.scene) finalizeGun(collada.scene);
          else logError('Falha ao carregar arma em qualquer formato.');
        }, undefined, err3 => logError('Falha ao carregar Gun.dae: ' + err3));
      });
    });
  }, undefined, err => {
    console.warn('MTL não carregou:', err);
    // fallback: tenta OBJ
    objLoader.load(FILES.gunOBJ, obj2 => finalizeGun(obj2), undefined, err2 => {
      console.warn('OBJ falhou (fallback):', err2);
      // DAE fallback
      daeLoader.load(FILES.gunDAE, collada => { if (collada && collada.scene) finalizeGun(collada.scene); }, undefined, err3 => {
        logError('Nenhuma arma carregou — será usado fallback visual.');
      });
    });
  });
}

function finalizeGun(obj){
  gun = obj;
  gun.traverse(c => {
    if (c.isMesh){
      c.castShadow = true; c.receiveShadow = false;
      if (!c.material.map){
        texLoader.load(FILES.gunPNG, tex => { c.material.map = tex; c.material.needsUpdate = true; }, undefined, ()=> console.warn('Gun.png não aplicado'));
      }
    }
  });
  gun.scale.set(0.7,0.7,0.7);
  gun.position.set(0.55,-0.38,-0.6);
  camera.add(gun);
  scene.add(camera); // garante camera na cena
  console.log('Arma anexada');
}

/* ========== ZOMBIE LOADER ========== */
function loadZombieAssets(){
  // usamos idle.fbx como principal para mesh se ela trouxer mesh; caso contrário usamos placeholder
  // Carrega idle.fbx -> se tiver mesh+animations usamos; também tentamos run/jump para animações
  fbxLoader.load(FILES.fbxIdle, obj => {
    // se o FBX contiver mesh, usa como visual; otherwise usamos animations se presente
    const hasMesh = obj.children && obj.children.length && obj.children.some(c=>c.isMesh);
    if (hasMesh){
      zombieTemplate.mesh = obj;
      zombieTemplate.mesh.traverse(c => { if (c.isMesh) { c.castShadow=true; c.receiveShadow=true; } });
      // normalizamos escala (ajuste se necessário)
      zombieTemplate.mesh.scale.set(0.008,0.008,0.008);
    }
    if (obj.animations && obj.animations.length) zombieTemplate.animations['idle'] = obj.animations[0];
    console.log('idle.fbx carregado (mesh?', !!hasMesh, ', anims:', obj.animations ? obj.animations.length : 0, ')');
  }, undefined, err => {
    console.warn('idle.fbx não carregou:', err);
  });

  // run
  fbxLoader.load(FILES.fbxRun, obj => {
    if (obj.animations && obj.animations.length) zombieTemplate.animations['run'] = obj.animations[0];
    console.log('run.fbx carregado (anims:', obj.animations ? obj.animations.length : 0, ')');
  }, undefined, err => {
    console.warn('run.fbx não carregou:', err);
  });

  // jump
  fbxLoader.load(FILES.fbxJump, obj => {
    if (obj.animations && obj.animations.length) zombieTemplate.animations['jump'] = obj.animations[0];
    console.log('jump.fbx carregado (anims:', obj.animations ? obj.animations.length : 0, ')');
  }, undefined, err => {
    console.warn('jump.fbx não carregou:', err);
  });

  // se nenhum mesh for fornecido, preencha mesh com placeholder imediatamente (para evitar tela preta)
  // (mantemos isto, porque se idle.fbx demora, queremos começar com placeholder)
  if (!zombieTemplate.mesh){
    const placeholder = new THREE.Group();
    const box = new THREE.Mesh(new THREE.BoxGeometry(0.6,1.6,0.6), new THREE.MeshStandardMaterial({color:0x556b3a}));
    box.castShadow=true; box.receiveShadow=true; box.position.y = 0.8;
    placeholder.add(box);
    zombieTemplate.mesh = placeholder;
  }
}

/* ========== SPAWN ZOMBIE ========== */
function spawnZombie(pos){
  const id = 'z'+(++zcount);
  // clone visual (se não tiver mesh, zombieTemplate.mesh já é placeholder)
  let visual;
  try { visual = zombieTemplate.mesh.clone(true); } catch(e) { 
    // fallback seguro
    visual = new THREE.Mesh(new THREE.BoxGeometry(0.6,1.6,0.6), new THREE.MeshStandardMaterial({color:0x556b3a}));
    visual.position.y=0.8; visual.castShadow=true; visual.receiveShadow=true;
  }
  const g = new THREE.Group();
  g.add(visual);
  g.position.copy(pos || new THREE.Vector3((Math.random()-0.5)*10, 0, -6 - Math.random()*8));
  g.scale.set(1,1,1);
  g.userData = { id, speed: 0.8 + Math.random()*0.8, mixer: null, hp:10 };

  // aplica animação 'run' se existir
  if (zombieTemplate.animations['run']){
    try {
      const mixer = new THREE.AnimationMixer(g);
      const clip = zombieTemplate.animations['run'];
      const action = mixer.clipAction(clip);
      action.timeScale = 1 + (Math.random()-0.5)*0.15;
      action.play();
      g.userData.mixer = mixer;
      activeMixers.push(mixer);
    } catch(e){ console.warn('Erro ao iniciar mixer do zumbi', e); }
  }

  scene.add(g);
  zombies[id] = g;
  console.log('Zumbi spawnado', id);
  return id;
}

/* ========== GAME LOOP ========== */
function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(0.05, (clock.getDelta && clock.getDelta()) || 0.016);

  // mixers
  for (let i = activeMixers.length-1; i>=0; i--){
    const m = activeMixers[i];
    if (!m){ activeMixers.splice(i,1); continue; }
    try { m.update(dt); } catch(e){ console.warn('mixer.update falhou', e); }
  }

  // update simple player/zombies
  updatePlayer(dt);
  updateZombies(dt);

  renderer.render(scene, camera);
}

function updatePlayer(dt){
  // compute forward + right (CORREÇÃO: forward x up para direito correto)
  const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
  const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

  const move = new THREE.Vector3();
  if (keys.w) move.add(forward);
  if (keys.s) move.add(forward.clone().negate());
  if (keys.a) move.add(right.clone().negate());
  if (keys.d) move.add(right);

  if (move.lengthSq() > 0.0001){
    move.normalize();
    player.pos.addScaledVector(move, player.speed * dt);
  }

  // camera follow
  camera.position.lerp(new THREE.Vector3(player.pos.x, player.pos.y + 1.6, player.pos.z + 5), 0.08);
  camera.lookAt(player.pos.x, player.pos.y + 0.6, player.pos.z);
}

function updateZombies(dt){
  const p = player.pos;
  Object.keys(zombies).forEach(id => {
    const g = zombies[id];
    if (!g) return;
    const dir = new THREE.Vector3(p.x - g.position.x, 0, p.z - g.position.z);
    const d = dir.length();
    if (d > 0.8){ dir.normalize(); g.position.addScaledVector(dir, (g.userData.speed||1) * dt); g.lookAt(p.x, g.position.y, p.z); }
  });
}

/* ========== INPUT ========== */
function onKeyDown(e){
  if (e.code === 'KeyW') keys.w = true;
  if (e.code === 'KeyS') keys.s = true;
  if (e.code === 'KeyA') keys.a = true;
  if (e.code === 'KeyD') keys.d = true;
  if (e.code === 'Space' && player.onGround){ player.onGround = false; player.pos.y += 0.5; } // simple jump
}
function onKeyUp(e){
  if (e.code === 'KeyW') keys.w = false;
  if (e.code === 'KeyS') keys.s = false;
  if (e.code === 'KeyA') keys.a = false;
  if (e.code === 'KeyD') keys.d = false;
}

/* ========== MOBILE JOYSTICK ========== */
function setupJoystick(){
  const joy = document.getElementById('joystick');
  const fire = document.getElementById('fireBtn');
  if (!joy) return;
  let dragging = false, origin = null;
  joy.addEventListener('pointerdown', ev => { joy.setPointerCapture(ev.pointerId); dragging=true; origin={x:ev.clientX,y:ev.clientY}; joy.style.background='rgba(255,255,255,0.02)'; });
  joy.addEventListener('pointermove', ev => {
    if (!dragging) return;
    const dx = ev.clientX - origin.x, dy = ev.clientY - origin.y;
    keys.w = dy < -20; keys.s = dy > 20; keys.a = dx < -20; keys.d = dx > 20;
  });
  joy.addEventListener('pointerup', ev => { dragging=false; keys.w=keys.s=keys.a=keys.d=false; joy.style.background=''; });
  if (fire) fire.addEventListener('pointerdown', spawnMuzzleFlash);
}

/* ========== MUZZLE ========== */
function spawnMuzzleFlash(){
  const geo = new THREE.PlaneGeometry(0.45,0.45);
  const mat = new THREE.MeshBasicMaterial({ color:0xffe7c7, transparent:true, opacity:0.95, side:THREE.DoubleSide });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(camera.position).add(new THREE.Vector3(0, -0.25, -0.9).applyQuaternion(camera.quaternion));
  mesh.quaternion.copy(camera.quaternion);
  scene.add(mesh);
  setTimeout(()=> scene.remove(mesh), 90);
}

/* ========== UTIL ========== */
function toggleShadows(){ renderer.shadowMap.enabled = !renderer.shadowMap.enabled; document.getElementById('btnShadows').innerText = 'Sombras: ' + (renderer.shadowMap.enabled ? 'ON' : 'OFF'); }
function toggleDebug(){ Object.keys(zombies).forEach(id => { const g = zombies[id]; if (!g.userData._bh){ const bh = new THREE.BoxHelper(g, 0xff0000); scene.add(bh); g.userData._bh = bh; } else { scene.remove(g.userData._bh); delete g.userData._bh; } }); }
function onResize(){ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

console.log('Esperados (case-sensitive):', FILES);
</script>
</body>
</html>
