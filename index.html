<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Zombie Survival 3D — Enhanced</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root { --accent: #ff3b3b; --muted: #bfbfbf; --bg: #020205; }
  html,body{height:100%;margin:0;font-family:'Chakra Petch',sans-serif;background:linear-gradient(180deg,#08060a 0%, #1b1a1f 100%); color: #e6e6e6;}
  #game-container{width:100vw;height:100vh;overflow:hidden;position:relative;}
  .hud{position:fixed;left:16px;top:16px;z-index:30;background:linear-gradient(180deg,rgba(10,10,10,0.6),rgba(10,10,10,0.3));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);}
  .hud .bar{height:12px;background:#222;border-radius:8px;overflow:hidden}
  .hud .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#ffb7b7);width:100%}
  .center-hud{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;z-index:30;background:rgba(0,0,0,0.45);padding:10px 18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);}
  .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(0,0,0,0.7),rgba(0,0,0,0.85));z-index:40}
  .card{background:linear-gradient(180deg,#0f0f12,#17171b);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);width:min(760px,95%);}
  #crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:10px;height:10px;border-radius:50%;z-index:35;mix-blend-mode:screen;pointer-events:none;opacity:0.9}
  #crosshair::after{content:'';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:2px;height:2px;background:var(--accent);box-shadow:0 0 8px var(--accent)}
  button.btn{background:var(--accent);color:white;padding:10px 14px;border-radius:8px;border:none;cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  #mobile-controls{position:fixed;left:0;right:0;bottom:0;height:160px;display:none;z-index:29;pointer-events:none}
  .hidden{display:none!important}
  #hit-flash{position:fixed;inset:0;background:rgba(255,0,0,0.06);z-index:50;pointer-events:none;opacity:0;transition:opacity 160ms}
  #mobile-fire{position:fixed;right:18px;bottom:24px;background:rgba(0,0,0,0.45);padding:18px;border-radius:50%;z-index:60;color:white;display:none}
  #ammo { font-weight:700; margin-left:8px; }
</style>
</head>
<body>
<div id="game-container"></div>
<div id="crosshair"></div>
<div id="hit-flash"></div>
<button id="mobile-fire">FIRE</button>

<div class="hud" id="left-hud">
  <div style="display:flex;gap:12px;align-items:center;">
    <div>
      <div class="small">VIDA</div>
      <div class="bar" style="width:160px"><i id="health-bar" style="width:100%"></i></div>
    </div>
    <div style="min-width:130px">
      <div class="small">PONTOS</div>
      <div id="score" style="font-weight:700;font-size:18px">0</div>
    </div>
    <div style="min-width:160px">
      <div class="small">ARMA <span id="weapon-name" style="font-weight:700">Pistola</span></div>
      <div class="small">MUNIÇÃO: <span id="ammo">12</span>/<span id="mag-cap">12</span></div>
    </div>
  </div>
</div>

<div class="center-hud hidden" id="powerup">DANO DUPLO ATIVO</div>

<div id="lobby" class="modal">
  <div class="card">
    <h1 style="font-size:32px;color:var(--accent);margin:0 0 8px 0">Zombie Survival 3D — Enhanced</h1>
    <p class="small">Modo híbrido: suporta <strong>offline</strong> (sem Firebase) e <strong>online</strong> com Firebase se você fornecer a configuração. Skins procedurais, luzes, som e gameplay finalizado.</p>
    <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap;">
      <input id="name" class="input" placeholder="Seu nome" style="flex:1;padding:10px;border-radius:8px;background:#111;border:1px solid rgba(255,255,255,0.03);color:white" />
      <select id="mode" style="padding:10px;border-radius:8px;background:#111;border:1px solid rgba(255,255,255,0.03);color:white">
        <option value="offline">Offline (local)</option>
        <option value="online">Online (Firebase) — opcional</option>
      </select>
      <button id="start" class="btn">Iniciar Jogo</button>
    </div>
    <div style="margin-top:10px" class="small">Dica: se escolher <em>Online</em>, abra <code>index.html</code> e defina a variável <code>FIREBASE_CONFIG</code> com seu objeto de configuração (veja README).</div>
  </div>
</div>

<div id="game-over" class="modal hidden">
  <div class="card" style="text-align:center;">
    <h2 style="color:var(--accent);font-size:28px">Você morreu</h2>
    <p id="final-score" style="font-weight:700;font-size:20px">0</p>
    <div style="display:flex;gap:10px;margin-top:12px">
      <button id="restart" class="btn">Jogar Novamente</button>
      <button id="download" class="btn" style="background:#3b82f6">Baixar ZIP</button>
    </div>
    <p class="small" style="margin-top:8px">Gerado localmente: dicas e relatório final disponíveis.</p>
    <div style="margin-top:10px" id="report" class="small"></div>
  </div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { PointerLockControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js";

  // Optional Firebase hook (keep null by default)
  const FIREBASE_CONFIG = null;

  // DOM
  const container = document.getElementById('game-container');
  const lobby = document.getElementById('lobby');
  const startBtn = document.getElementById('start');
  const nameInput = document.getElementById('name');
  const modeSelect = document.getElementById('mode');
  const crosshair = document.getElementById('crosshair');
  const gameOverModal = document.getElementById('game-over');
  const restartBtn = document.getElementById('restart');
  const scoreEl = document.getElementById('score');
  const healthBar = document.getElementById('health-bar');
  const powerupEl = document.getElementById('powerup');
  const finalScoreEl = document.getElementById('final-score');
  const reportEl = document.getElementById('report');
  const hitFlash = document.getElementById('hit-flash');
  const mobileFire = document.getElementById('mobile-fire');
  const ammoEl = document.getElementById('ammo');
  const weaponNameEl = document.getElementById('weapon-name');
  const magCapEl = document.getElementById('mag-cap');

  // three
  let scene, camera, renderer, clock, controls;
  let localPlayer = { name: 'Player', health: 100, score: 0, damageMultiplier: 1, isAlive: true, position: new THREE.Vector3(), weapon: 'pistol', ammo: 12, magCap: 12 };
  let zombies = {};
  let zombieObjects = {};
  let gameActive = false;
  let lastSpawn = 0;
  let lastAttack = 0;
  let audioCtx;
  let gunBuffer, hitBuffer, deathBuffer;
  let keys = {};
  let velocity = new THREE.Vector3();
  let canJump = true;
  const MAX_ZOMBIES = 45;

  init();

  function init() {
    // renderer + scene
    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0c0b0d, 0.0025);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0,1.6,0);

    clock = new THREE.Clock();

    // lights
    const hemi = new THREE.HemisphereLight(0x8a7f7a, 0x101014, 0.8);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffcc88, 1.0);
    dir.position.set(-30,40,20);
    dir.castShadow = true;
    dir.shadow.camera.left = -80; dir.shadow.camera.right = 80; dir.shadow.camera.top = 80; dir.shadow.camera.bottom = -80;
    dir.shadow.mapSize.set(2048,2048);
    scene.add(dir);

    // ground
    const groundMat = new THREE.MeshStandardMaterial({color:0x222222, roughness:0.7, metalness:0.05});
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // sky
    const skyGeo = new THREE.SphereGeometry(500, 32, 32);
    const skyMat = new THREE.MeshBasicMaterial({color:0x0a0a0b, side: THREE.BackSide});
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // environment scatter
    for (let i=0;i<35;i++){
      const box = new THREE.Mesh(new THREE.BoxGeometry(1+Math.random()*6,0.5+Math.random()*2,1+Math.random()*6), new THREE.MeshStandardMaterial({color:0x2b2b2b, roughness:0.8}));
      box.position.set((Math.random()-0.5)*400, 0.25, (Math.random()-0.5)*400);
      box.castShadow = true; box.receiveShadow = true;
      scene.add(box);
    }

    // controls
    controls = new PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());

    // player weapon
    const pistol = createPistolModel();
    camera.add(pistol);
    pistol.position.set(0.25,-0.3,-0.6);

    // pointer lock interactions
    document.addEventListener('click', (ev) => {
      if (!gameActive) return;
      if (!controls.isLocked) controls.lock();
    });

    // input and UI
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', restartGame);
    window.addEventListener('resize', onResize);
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);
    window.addEventListener('mousedown', onMouseDown);
    mobileFire.addEventListener('touchstart', (e)=>{ e.preventDefault(); onMobileFire(); }, {passive:false});
    mobileFire.addEventListener('mousedown', onMobileFire);

    // audio
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){ audioCtx = null; }
    if (audioCtx) {
      gunBuffer = makeGunShotBuffer();
      hitBuffer = makeHitBuffer();
      deathBuffer = makeDeathBuffer();
    }

    // create sample zombie skins pool
    window.__Z_SKIN_POOL = [];
    for (let i=0;i<8;i++) window.__Z_SKIN_POOL.push(generateZombieSkin(i));

    animate();
    updateHUD();
    checkMobile();
  }

  function checkMobile() {
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    if (isMobile) {
      mobileFire.style.display = 'block';
    }
  }

  function startGame() {
    localPlayer.name = nameInput.value.trim() || 'Sobrevivente';
    lobby.classList.add('hidden');
    gameActive = true;
    localPlayer.health = 100; localPlayer.score = 0; localPlayer.isAlive = true;
    localPlayer.weapon = 'pistol'; localPlayer.ammo = localPlayer.magCap = 12;
    scoreEl.textContent = '0';
    healthBar.style.width = '100%';
    crosshair.style.display = 'block';
    controls.lock();
    lastSpawn = Date.now();
  }

  function restartGame() {
    gameOverModal.classList.add('hidden');
    // cleanup
    Object.keys(zombieObjects).forEach(id => {
      scene.remove(zombieObjects[id]);
      delete zombieObjects[id]; delete zombies[id];
    });
    startGame();
  }

  function onResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, clock.getDelta()); // clamp dt for stability
    if (gameActive) {
      applyMovement(dt);
      hostTick(dt);
      updateZombies(dt);
      handleCollisions();
      updateUI();
    }
    renderer.render(scene, camera);
  }

  function hostTick(dt) {
    // spawn logic with cap
    if (Date.now() - lastSpawn > Math.max(800, 3000 - localPlayer.score/20) && Object.keys(zombieObjects).length < MAX_ZOMBIES) {
      lastSpawn = Date.now();
      spawnZombie();
    }
    // spawn occasional powerup near player
    if (Math.random() < 0.0009) spawnPowerup();
  }

  function spawnZombie() {
    const id = 'z_' + Date.now() + '_' + Math.floor(Math.random()*1000);
    const angle = Math.random() * Math.PI * 2;
    const r = 60 + Math.random()*120;
    const x = Math.cos(angle)*r + (Math.random()-0.5)*10;
    const z = Math.sin(angle)*r + (Math.random()-0.5)*10;
    const skinTexture = window.__Z_SKIN_POOL[Math.floor(Math.random()*window.__Z_SKIN_POOL.length)];
    const bodyMat = new THREE.MeshStandardMaterial({map: skinTexture, roughness:0.9, metalness:0.0});
    const legsMat = new THREE.MeshStandardMaterial({color:0x1d1d1d, roughness:0.95});
    const group = new THREE.Group();
    const legs = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.45,0.7,8), legsMat);
    legs.position.y = 0.35;
    const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.45,0.9,8), bodyMat);
    torso.position.y = 1.0; torso.name = 'body';
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.32, 12, 8), bodyMat);
    head.position.y = 1.6;
    group.add(legs, torso, head);
    group.position.set(x,0,z);
    group.userData = { id, health: 100, speed: 0.5 + Math.random()*0.9, damage: 6 + Math.floor(Math.random()*18), _offset: Math.random()*10 };
    group.traverse((m)=>{ m.castShadow = true; m.receiveShadow = true; });
    scene.add(group);
    zombieObjects[id] = group;
    zombies[id] = group.userData;
  }

  function updateZombies(dt) {
    const pPos = new THREE.Vector3();
    controls.getObject().getWorldPosition(pPos);
    localPlayer.position.copy(pPos);
    Object.entries(zombieObjects).forEach(([id, obj]) => {
      if (!obj) return;
      const data = obj.userData;
      // remove if too far or too many seconds alive offscreen
      const distToPlayer = obj.position.distanceTo(pPos);
      if (distToPlayer > 800) {
        scene.remove(obj);
        delete zombieObjects[id]; delete zombies[id];
        return;
      }
      // movement towards player on XZ plane
      const target = new THREE.Vector3(pPos.x, obj.position.y, pPos.z);
      const dir = target.clone().sub(obj.position);
      const dist = dir.length();
      if (dist > 0.01) dir.normalize();
      const speed = data.speed * (1 + localPlayer.score/1500);
      obj.position.addScaledVector(dir, speed * dt);
      // rotate smoothly towards player (Y only)
      const desiredAngle = Math.atan2(pPos.x - obj.position.x, pPos.z - obj.position.z);
      obj.rotation.y += (desiredAngle - obj.rotation.y) * 0.08;

      // subtle bob
      const t = performance.now()/400 + (obj.userData._offset || 0);
      obj.position.y = Math.abs(Math.sin(performance.now()/300 + (obj.userData._offset||0))*0.04);

      // attack if near
      if (dist < 1.4 && gameActive) {
        if (!obj.userData._lastHit || Date.now() - obj.userData._lastHit > 1000) {
          obj.userData._lastHit = Date.now();
          localPlayer.health -= obj.userData.damage;
          triggerHitFlash();
          if (localPlayer.health <= 0) {
            localPlayer.health = 0;
            playerDied();
          }
        }
      }
    });
  }

  function handleCollisions() {
    // used for future physics; currently shooting is raycast-based in shoot()
  }

  function onMouseDown(e) {
    if (!gameActive) return;
    if (e.button === 0) shoot();
  }

  function onMobileFire() {
    if (!gameActive) return;
    shoot();
  }

  function onKeyDown(e) {
    if (e.code === 'KeyQ') switchWeapon();
    if (e.code === 'KeyE') interactChest();
    if (e.code === 'KeyR') reload();
    keys[e.code] = true;
  }
  function onKeyUp(e) { keys[e.code] = false; }

  function applyMovement(dt) {
    const speedWalk = 6;
    const speedRun = 9;
    const forward = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0);
    const side = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0);
    const isRunning = keys['ShiftLeft'] || keys['ShiftRight'];
    const speed = isRunning ? speedRun : speedWalk;
    const velocityX = side * speed * dt;
    const velocityZ = forward * speed * dt;
    controls.getObject().translateX(velocityX);
    controls.getObject().translateZ(velocityZ);
    // gravity
    velocity.y -= 9.8 * dt;
    controls.getObject().position.y += velocity.y * dt;
    if (controls.getObject().position.y < 1.6) {
      velocity.y = 0;
      controls.getObject().position.y = 1.6;
      canJump = true;
    }
    if (keys['Space'] && canJump) {
      velocity.y = 5; canJump = false;
    }
  }

  function shoot() {
    const now = performance.now();
    if (now - lastAttack < 120) return;
    lastAttack = now;
    if (localPlayer.ammo <= 0) { playEmptyClick(); return; }
    localPlayer.ammo--;
    updateHUD();
    if (audioCtx && gunBuffer) playBuffer(gunBuffer);
    camera.rotation.x = Math.max(camera.rotation.x - 0.03, -0.6);
    const ray = new THREE.Raycaster();
    ray.setFromCamera({x:0,y:0}, camera);
    const allParts = [];
    Object.values(zombieObjects).forEach(z => z.children.forEach(c => allParts.push(c)));
    const hits = ray.intersectObjects(allParts, false);
    if (hits.length) {
      const hit = hits[0];
      let parent = hit.object.parent;
      const zid = Object.keys(zombieObjects).find(k=>zombieObjects[k]===parent);
      if (zid) {
        damageZombie(zid, 35);
        flashCrosshair();
      }
      if (audioCtx && hitBuffer) playBuffer(hitBuffer);
    }
  }

  function damageZombie(id, dmg) {
    const obj = zombieObjects[id];
    if (!obj) return;
    obj.userData.health -= dmg * localPlayer.damageMultiplier;
    obj.traverse(m => { if (m.material && m.material.emissive) m.material.emissive.setHex(0x442222); });
    setTimeout(()=>{ obj.traverse(m => { if (m.material && m.material.emissive) m.material.emissive.setHex(0x000000); }); }, 120);
    if (obj.userData.health <= 0) {
      if (audioCtx && deathBuffer) playBuffer(deathBuffer);
      localPlayer.score += 100;
      scoreEl.textContent = localPlayer.score;
      const idobj = obj;
      const start = performance.now();
      const duration = 450;
      (function anim() {
        const t = (performance.now()-start)/duration;
        if (t < 1) {
          const scale = 1 - t;
          idobj.scale.setScalar(scale);
          requestAnimationFrame(anim);
        } else {
          if (Math.random() < 0.12) spawnHealthPack(idobj.position);
          scene.remove(idobj);
          delete zombieObjects[id]; delete zombies[id];
        }
      })();
    }
  }

  function playerDied() {
    if (!gameActive) return;
    gameActive = false;
    try { controls.unlock(); } catch(e){}
    crosshair.style.display = 'none';
    finalScoreEl.textContent = 'Pontuação final: ' + localPlayer.score;
    reportEl.textContent = `O sobrevivente ${localPlayer.name} eliminou ${Math.floor(localPlayer.score/100)} zumbis antes de cair.`;
    gameOverModal.classList.remove('hidden');
  }

  function updateUI() {
    healthBar.style.width = Math.max(0, localPlayer.health) + '%';
    scoreEl.textContent = localPlayer.score;
    if (localPlayer.damageMultiplier > 1) powerupEl.classList.remove('hidden'); else powerupEl.classList.add('hidden');
    updateHUD();
  }
  function updateHUD() {
    ammoEl.textContent = localPlayer.ammo;
    weaponNameEl.textContent = localPlayer.weapon === 'pistol' ? 'Pistola' : localPlayer.weapon;
    magCapEl.textContent = localPlayer.magCap;
  }

  function switchWeapon() {
    if (localPlayer.weapon === 'melee') {
      localPlayer.weapon='pistol';
      localPlayer.magCap = 12;
      localPlayer.ammo = Math.max(localPlayer.ammo, 6);
    } else {
      localPlayer.weapon='melee';
      localPlayer.magCap = 0;
      localPlayer.ammo = 0;
    }
    updateHUD();
  }

  function reload() {
    if (localPlayer.weapon !== 'pistol') return;
    localPlayer.ammo = localPlayer.magCap;
    updateHUD();
  }

  function interactChest() {
    localPlayer.damageMultiplier = 2.0;
    setTimeout(()=>{ localPlayer.damageMultiplier = 1.0; }, 20000);
  }

  function spawnPowerup() {
    const pos = localPlayer.position.clone();
    pos.x += (Math.random()-0.5)*8;
    pos.z += (Math.random()-0.5)*8;
    const geo = new THREE.SphereGeometry(0.35,8,8);
    const mat = new THREE.MeshStandardMaterial({color:0x3bff9a, emissive:0x0f7f5a});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(pos.x, 0.6, pos.z);
    mesh.userData = { type: 'doubleDamage', ttl: Date.now() + 20000 };
    scene.add(mesh);
    (function check() {
      if (!mesh.parent) return;
      const dist = mesh.position.distanceTo(localPlayer.position);
      if (dist < 2) {
        localPlayer.damageMultiplier = 2.0;
        setTimeout(()=>{ localPlayer.damageMultiplier = 1.0; }, 20000);
        scene.remove(mesh);
        return;
      }
      if (Date.now() > mesh.userData.ttl) { scene.remove(mesh); return; }
      requestAnimationFrame(check);
    })();
  }

  function spawnHealthPack(atPos) {
    const pos = atPos ? atPos.clone() : localPlayer.position.clone();
    pos.x += (Math.random()-0.5)*4; pos.z += (Math.random()-0.5)*4;
    const geo = new THREE.BoxGeometry(0.6,0.35,0.6);
    const mat = new THREE.MeshStandardMaterial({color:0xff6666, emissive:0x331111});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(pos.x, 0.5, pos.z);
    mesh.userData = { type: 'health', ttl: Date.now() + 30000 };
    scene.add(mesh);
    (function check() {
      if (!mesh.parent) return;
      const dist = mesh.position.distanceTo(localPlayer.position);
      if (dist < 2) {
        localPlayer.health = Math.min(100, localPlayer.health + 40);
        scene.remove(mesh);
        return;
      }
      if (Date.now() > mesh.userData.ttl) { scene.remove(mesh); return; }
      requestAnimationFrame(check);
    })();
  }

  function flashCrosshair() {
    const old = crosshair.style.transform;
    crosshair.style.transform = 'translate(-50%,-50%) scale(0.8)';
    setTimeout(()=>{ crosshair.style.transform = old; }, 90);
  }

  function triggerHitFlash() {
    hitFlash.style.opacity = '1';
    setTimeout(()=>{ hitFlash.style.opacity = '0'; }, 120);
  }

  function playEmptyClick() {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type='triangle'; o.frequency.value = 220;
    g.gain.value = 0.02;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); setTimeout(()=>{ o.stop(); }, 80);
  }

  //
  // Audio helpers
  //
  function makeGunShotBuffer() {
    const ctx = audioCtx;
    const b = ctx.createBuffer(1, ctx.sampleRate*0.18, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/2000);
    return b;
  }
  function makeHitBuffer() {
    const ctx = audioCtx;
    const b = ctx.createBuffer(1, ctx.sampleRate*0.12, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i] = Math.sin(i*0.03) * Math.exp(-i/1200) * (Math.random()*0.6+0.2);
    return b;
  }
  function makeDeathBuffer() {
    const ctx = audioCtx;
    const b = ctx.createBuffer(1, ctx.sampleRate*0.36, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i] = Math.sin(i*0.008) * Math.exp(-i/3000) * (Math.random()*0.5+0.3);
    return b;
  }
  function playBuffer(buffer) {
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.connect(audioCtx.destination);
    src.start();
  }

  //
  // procedural zombie skin generator using canvas -> texture
  //
  function generateZombieSkin(seed=0) {
    const size = 512;
    const cvs = document.createElement('canvas');
    cvs.width = cvs.height = size;
    const ctx = cvs.getContext('2d');
    const base = `hsl(${Math.floor(80 + Math.random()*40)}, ${20+Math.random()*30}%, ${20+Math.random()*30}%)`;
    ctx.fillStyle = base;
    ctx.fillRect(0,0,size,size);
    for (let i=0;i<40;i++){
      ctx.fillStyle = `rgba(${50+Math.random()*90}, ${10+Math.random()*90}, ${10+Math.random()*80}, ${0.08+Math.random()*0.28})`;
      const w = 20 + Math.random()*140;
      const h = 20 + Math.random()*140;
      ctx.beginPath();
      ctx.ellipse(Math.random()*size, Math.random()*size, w, h, Math.random()*Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.lineWidth = 6;
    for (let i=0;i<6;i++){
      ctx.strokeStyle = `rgba(${80+Math.random()*80},${80+Math.random()*80},${80+Math.random()*60},${0.06})`;
      ctx.beginPath();
      ctx.moveTo(Math.random()*size, Math.random()*size);
      ctx.lineTo(Math.random()*size, Math.random()*size);
      ctx.stroke();
    }
    for (let s=0;s<120;s++){
      ctx.strokeStyle = `rgba(120,40,30,${0.1+Math.random()*0.2})`;
      ctx.beginPath();
      ctx.moveTo(Math.random()*size, Math.random()*size);
      ctx.lineTo(Math.random()*size, Math.random()*size);
      ctx.stroke();
    }
    const tex = new THREE.CanvasTexture(cvs);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(1,1);
    return tex;
  }

  function createPistolModel() {
    const group = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({color:0x111111, roughness:0.6});
    const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.06,0.4), mat);
    const grip = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.05,0.25), mat);
    grip.position.set(0,-0.08, -0.05);
    barrel.position.set(0, -0.02, -0.25);
    group.add(barrel, grip);
    return group;
  }

  // download helper
  document.getElementById('download').addEventListener('click', () => {
    alert('Você pode baixar o projeto pedindo: "Gera o zip" — eu posso gerar o ZIP do jogo atualizado para você.');
  });

</script>
</body>
</html>
