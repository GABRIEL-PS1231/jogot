<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Zombie Survival 3D — Enhanced</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap" rel="stylesheet">
<!-- inline minimal favicon (avoids 404) -->
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16'%3E%3Crect width='16' height='16' fill='%23000'/%3E%3C/svg%3E">
<style>
  :root { --accent: #ff3b3b; --muted: #bfbfbf; --bg: #020205; }
  html,body{height:100%;margin:0;font-family:'Chakra Petch',sans-serif;background:linear-gradient(180deg,#08060a 0%, #1b1a1f 100%); color: #e6e6e6;}
  #game-container{width:100vw;height:100vh;overflow:hidden;position:relative;}
  .hud{position:fixed;left:16px;top:16px;z-index:30;background:linear-gradient(180deg,rgba(10,10,10,0.6),rgba(10,10,10,0.3));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);}
  .hud .bar{height:12px;background:#222;border-radius:8px;overflow:hidden}
  .hud .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#ffb7b7);width:100%}
  .center-hud{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;z-index:30;background:rgba(0,0,0,0.45);padding:10px 18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);}
  .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(0,0,0,0.7),rgba(0,0,0,0.85));z-index:40}
  .card{background:linear-gradient(180deg,#0f0f12,#17171b);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);width:min(760px,95%);}
  #crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:10px;height:10px;border-radius:50%;z-index:35;mix-blend-mode:screen;pointer-events:none;opacity:0.9}
  #crosshair::after{content:'';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:2px;height:2px;background:var(--accent);box-shadow:0 0 8px var(--accent)}
  button.btn{background:var(--accent);color:white;padding:10px 14px;border-radius:8px;border:none;cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  #mobile-controls{position:fixed;left:0;right:0;bottom:0;height:160px;display:none;z-index:29;pointer-events:none}
  .hidden{display:none!important}
  #hit-flash{position:fixed;inset:0;background:rgba(255,0,0,0.06);z-index:50;pointer-events:none;opacity:0;transition:opacity 160ms}
  #mobile-fire{position:fixed;right:18px;bottom:24px;background:rgba(0,0,0,0.45);padding:18px;border-radius:50%;z-index:60;color:white;display:none}
  #ammo { font-weight:700; margin-left:8px; }
</style>

<!-- Import map (keeps imports short and avoids bundler) -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

</head>
<body>
<div id="game-container"></div>
<div id="crosshair"></div>
<div id="hit-flash"></div>
<button id="mobile-fire">FIRE</button>

<div class="hud" id="left-hud">
  <div style="display:flex;gap:12px;align-items:center;">
    <div>
      <div class="small">VIDA</div>
      <div class="bar" style="width:160px"><i id="health-bar" style="width:100%"></i></div>
    </div>
    <div style="min-width:130px">
      <div class="small">PONTOS</div>
      <div id="score" style="font-weight:700;font-size:18px">0</div>
    </div>
    <div style="min-width:160px">
      <div class="small">ARMA <span id="weapon-name" style="font-weight:700">Pistola</span></div>
      <div class="small">MUNIÇÃO: <span id="ammo">12</span>/<span id="mag-cap">12</span></div>
    </div>
  </div>
</div>

<div class="center-hud hidden" id="powerup">DANO DUPLO ATIVO</div>

<div id="lobby" class="modal">
  <div class="card">
    <h1 style="font-size:32px;color:var(--accent);margin:0 0 8px 0">Zombie Survival 3D — Enhanced</h1>
    <p class="small">Digite seu nome para sobreviver. Skins procedurais, luzes, som e gameplay finalizado.</p>
    <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap;">
      <input id="name" class="input" placeholder="Seu nome" style="flex:1;padding:10px;border-radius:8px;background:#111;border:1px solid rgba(255,255,255,0.03);color:white" />
      <button id="start" class="btn">Iniciar Jogo</button>
    </div>
  </div>
</div>

<div id="game-over" class="modal hidden">
  <div class="card" style="text-align:center;">
    <h2 style="color:var(--accent);font-size:28px">Você morreu</h2>
    <p id="final-score" style="font-weight:700;font-size:20px">0</p>
    <div style="display:flex;gap:10px;margin-top:12px">
      <button id="restart" class="btn">Jogar Novamente</button>
      <button id="download" class="btn" style="background:#3b82f6">Baixar ZIP</button>
    </div>
    <p class="small" style="margin-top:8px">Gerado localmente: dicas e relatório final disponíveis.</p>
    <div style="margin-top:10px" id="report" class="small"></div>
  </div>
</div>

<script type="module">
  import * as THREE from "three";
  import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

  // Optional Firebase hook (keep null by default)
  const FIREBASE_CONFIG = null;

  // DOM
  const container = document.getElementById('game-container');
  const lobby = document.getElementById('lobby');
  const startBtn = document.getElementById('start');
  const nameInput = document.getElementById('name');
  const crosshair = document.getElementById('crosshair');
  const gameOverModal = document.getElementById('game-over');
  const restartBtn = document.getElementById('restart');
  const scoreEl = document.getElementById('score');
  const healthBar = document.getElementById('health-bar');
  const powerupEl = document.getElementById('powerup');
  const finalScoreEl = document.getElementById('final-score');
  const reportEl = document.getElementById('report');
  const hitFlash = document.getElementById('hit-flash');
  const mobileFire = document.getElementById('mobile-fire');
  const ammoEl = document.getElementById('ammo');
  const weaponNameEl = document.getElementById('weapon-name');
  const magCapEl = document.getElementById('mag-cap');

  // three
  let scene, camera, renderer, clock, controls, pistolModel, skyMesh;
  let localPlayer = { name: 'Player', health: 100, score: 0, damageMultiplier: 1, isAlive: true, position: new THREE.Vector3(), weapon: 'pistol', ammo: 12, magCap: 12 };
  let zombies = {};
  let zombieObjects = {};
  let gameActive = false;
  let lastSpawn = 0;
  let lastAttack = 0;
  let audioCtx;
  let gunBuffer, hitBuffer, deathBuffer;
  let keys = {};
  let velocity = new THREE.Vector3();
  let canJump = true;
  const MAX_ZOMBIES = 45;

  init();

  function init() {
    // renderer + scene
    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0c0b0d, 0.0025);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1200);
    camera.position.set(0,1.6,0);

    clock = new THREE.Clock();

    // lights
    const hemi = new THREE.HemisphereLight(0x8a7f7a, 0x101014, 0.8);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffcc88, 1.0);
    dir.position.set(-30,40,20);
    dir.castShadow = true;
    dir.shadow.camera.left = -80; dir.shadow.camera.right = 80; dir.shadow.camera.top = 80; dir.shadow.camera.bottom = -80;
    dir.shadow.mapSize.set(1024,1024); // slightly smaller for perf
    scene.add(dir);

    // ground
    const groundMat = new THREE.MeshStandardMaterial({color:0x222222, roughness:0.7, metalness:0.05});
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // sky (procedural gradient texture for better look)
    createSky();

    // environment (lampposts/crates)
    createEnvironment(scene, 20);

    // environment scatter (extra objects)
    for (let i=0;i<48;i++){
      const box = new THREE.Mesh(new THREE.BoxGeometry(1+Math.random()*5,0.5+Math.random()*1.6,1+Math.random()*5), new THREE.MeshStandardMaterial({color:0x2b2b2b, roughness:0.85}));
      box.position.set((Math.random()-0.5)*400, 0.25, (Math.random()-0.5)*400);
      box.castShadow = true; box.receiveShadow = true;
      scene.add(box);
    }

    // controls
    controls = new PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());

    // player weapon
    pistolModel = createPistolModel();
    camera.add(pistolModel);
    pistolModel.position.set(0.25,-0.3,-0.6);

    // pointer lock interactions and audio resume
    document.addEventListener('click', (ev) => {
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){ audioCtx = null; }
        if (audioCtx) { gunBuffer = makeGunShotBuffer(); hitBuffer = makeHitBuffer(); deathBuffer = makeDeathBuffer(); }
      } else if (audioCtx.state === 'suspended') {
        audioCtx.resume().catch(()=>{});
      }
      if (!gameActive) return;
      if (!controls.isLocked) controls.lock();
    });

    // input and UI
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', restartGame);
    window.addEventListener('resize', onResize);
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);
    window.addEventListener('mousedown', onMouseDown);
    mobileFire.addEventListener('touchstart', (e)=>{ e.preventDefault(); onMobileFire(); }, {passive:false});
    mobileFire.addEventListener('mousedown', onMobileFire);

    // initial audio context creation allowed on init (kept lazy)
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){ audioCtx = null; }
    if (audioCtx) { gunBuffer = makeGunShotBuffer(); hitBuffer = makeHitBuffer(); deathBuffer = makeDeathBuffer(); }

    // create sample zombie skins pool
    window.__Z_SKIN_POOL = [];
    for (let i=0;i<10;i++) window.__Z_SKIN_POOL.push(generateZombieSkin(i));

    animate();
    updateHUD();
    checkMobile();
  }

  // create a nicer procedural sky texture and sphere
  function createSky() {
    const size = 1024;
    const cvs = document.createElement('canvas'); cvs.width = cvs.height = size;
    const ctx = cvs.getContext('2d');
    const g = ctx.createLinearGradient(0,0,0,size);
    g.addColorStop(0, '#061226');
    g.addColorStop(0.5, '#0b1220');
    g.addColorStop(1, '#12131a');
    ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
    ctx.globalAlpha = 0.06;
    for (let i=0;i<80;i++){
      ctx.fillStyle = `rgba(255,255,255,${0.02+Math.random()*0.06})`;
      ctx.beginPath();
      ctx.ellipse(Math.random()*size, Math.random()*size*0.7, 100+Math.random()*250, 30+Math.random()*80, Math.random()*Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
    const tex = new THREE.CanvasTexture(cvs);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(4,2);
    const mat = new THREE.MeshBasicMaterial({map: tex, side: THREE.BackSide});
    const sphere = new THREE.Mesh(new THREE.SphereGeometry(900, 32, 32), mat);
    sphere.rotation.x = Math.PI;
    scene.add(sphere);
    skyMesh = sphere;
  }

  // add lampposts and point lights
  function createEnvironment(scene, count = 20) {
    for (let i=0;i<count;i++){
      const x = (Math.random()-0.5)*400;
      const z = (Math.random()-0.5)*400;
      const post = new THREE.Group();
      const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.08,4,8), new THREE.MeshStandardMaterial({color:0x222222}));
      pole.position.y = 2;
      const lamp = new THREE.Mesh(new THREE.SphereGeometry(0.16, 10, 8), new THREE.MeshStandardMaterial({emissive:0xffe6b3, color:0x443322}));
      lamp.position.y = 4.2;
      post.add(pole, lamp);
      post.position.set(x,0,z);
      scene.add(post);
      const light = new THREE.PointLight(0xffddbb, 0.9, 14, 2);
      light.position.set(x,4.2,z);
      scene.add(light);
    }
  }

  function checkMobile() {
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    if (isMobile) {
      mobileFire.style.display = 'block';
    }
  }

  function startGame() {
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
    localPlayer.name = nameInput.value.trim() || 'Sobrevivente';
    lobby.classList.add('hidden');
    gameActive = true;
    localPlayer.health = 100; localPlayer.score = 0; localPlayer.isAlive = true;
    localPlayer.weapon = 'pistol'; localPlayer.ammo = localPlayer.magCap = 12;
    scoreEl.textContent = '0'; healthBar.style.width = '100%';
    crosshair.style.display = 'block';
    try { controls.lock(); } catch(e){}
    lastSpawn = Date.now();
  }

  function restartGame() {
    gameOverModal.classList.add('hidden');
    // cleanup zombies properly
    Object.keys(zombieObjects).forEach(id => {
      const obj = zombieObjects[id];
      if (obj) {
        obj.traverse(m => {
          if (m.geometry) m.geometry.dispose();
          if (m.material) { if (Array.isArray(m.material)) m.material.forEach(mt=>mt.dispose()); else m.material.dispose(); }
        });
        scene.remove(obj);
      }
      delete zombieObjects[id]; delete zombies[id];
    });
    startGame();
  }

  function onResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, clock.getDelta());
    if (gameActive) {
      applyMovement(dt);
      hostTick(dt);
      updateZombies(dt);
      handleCollisions();
      updateUI();

      // weapon recoil recovery (smooth)
      if (pistolModel) {
        pistolModel.rotation.x += (0 - pistolModel.rotation.x) * Math.min(1, dt * 6);
      }
    }
    renderer.render(scene, camera);
  }

  function hostTick(dt) {
    if (Date.now() - lastSpawn > Math.max(800, 2400 - localPlayer.score/15) && Object.keys(zombieObjects).length < MAX_ZOMBIES) {
      lastSpawn = Date.now();
      spawnZombie();
    }
    // occasional powerup / ammo spawn
    if (Math.random() < 0.0009) {
      if (Math.random() < 0.6) spawnAmmoPackNearPlayer(); else spawnPowerup();
    }
  }

  function spawnZombie() {
    const id = 'z_' + Date.now() + '_' + Math.floor(Math.random()*1000);
    const angle = Math.random() * Math.PI * 2;
    const r = 60 + Math.random()*120;
    const x = Math.cos(angle)*r + (Math.random()-0.5)*10;
    const z = Math.sin(angle)*r + (Math.random()-0.5)*10;
    const skinTexture = window.__Z_SKIN_POOL[Math.floor(Math.random()*window.__Z_SKIN_POOL.length)];
    const bodyMat = new THREE.MeshStandardMaterial({map: skinTexture, roughness:0.9, metalness:0.0});
    const legsMat = new THREE.MeshStandardMaterial({color:0x1d1d1d, roughness:0.95});
    const group = new THREE.Group();
    const legs = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.45,0.7,8), legsMat);
    legs.position.y = 0.35;
    const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.45,0.9,8), bodyMat);
    torso.position.y = 1.0; torso.name = 'body';
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.32, 12, 8), bodyMat);
    head.position.y = 1.6;
    group.add(legs, torso, head);
    group.position.set(x,0,z);
    // type-based variation (walker/runner/brute)
    const typeRoll = Math.random();
    let baseSpeed = 0.6, health=90, damage=8;
    if (typeRoll < 0.6) { baseSpeed = 0.6 + Math.random()*0.25; health = 80 + Math.random()*40; damage = 8 + Math.floor(Math.random()*8); }
    else if (typeRoll < 0.9) { baseSpeed = 1.2 + Math.random()*0.9; health = 45 + Math.random()*30; damage = 6 + Math.floor(Math.random()*6); }
    else { baseSpeed = 0.28 + Math.random()*0.22; health = 220 + Math.random()*120; damage = 22 + Math.floor(Math.random()*18); }
    group.userData = { id, health, speed: baseSpeed, damage, _offset: Math.random()*10, _lastHit: 0 };
    group.traverse((m)=>{ m.castShadow = true; m.receiveShadow = true; });
    scene.add(group);
    zombieObjects[id] = group;
    zombies[id] = group.userData;
  }

  function updateZombies(dt) {
    const pPos = new THREE.Vector3();
    controls.getObject().getWorldPosition(pPos);
    localPlayer.position.copy(pPos);
    Object.entries(zombieObjects).forEach(([id, obj]) => {
      if (!obj) return;
      const data = obj.userData;
      const distToPlayer = obj.position.distanceTo(pPos);
      if (distToPlayer > 900) {
        // dispose resources to avoid leaks
        obj.traverse(m => {
          if (m.geometry) m.geometry.dispose();
          if (m.material) { if (Array.isArray(m.material)) m.material.forEach(mt=>mt.dispose()); else m.material.dispose(); }
        });
        scene.remove(obj);
        delete zombieObjects[id]; delete zombies[id];
        return;
      }
      const target = new THREE.Vector3(pPos.x, obj.position.y, pPos.z);
      const dir = target.clone().sub(obj.position);
      const dist = dir.length();
      if (dist > 0.01) dir.normalize();
      const speed = data.speed * (1 + localPlayer.score/1500);
      obj.position.addScaledVector(dir, speed * dt);
      const desiredAngle = Math.atan2(pPos.x - obj.position.x, pPos.z - obj.position.z);
      obj.rotation.y += (desiredAngle - obj.rotation.y) * 0.08;
      obj.position.y = Math.abs(Math.sin(performance.now()/300 + (obj.userData._offset||0))*0.04);
      if (dist < 1.4 && gameActive) {
        if (!obj.userData._lastHit || Date.now() - obj.userData._lastHit > 1000) {
          obj.userData._lastHit = Date.now();
          localPlayer.health -= obj.userData.damage;
          triggerHitFlash();
          if (localPlayer.health <= 0) {
            localPlayer.health = 0;
            playerDied();
          }
        }
      }
    });
  }

  function handleCollisions() {}

  function onMouseDown(e) {
    if (!gameActive) return;
    if (e.button === 0) shoot();
  }

  function onMobileFire() {
    if (!gameActive) return;
    shoot();
  }

  function onKeyDown(e) {
    if (e.code === 'KeyQ') switchWeapon();
    if (e.code === 'KeyE') interactChest();
    if (e.code === 'KeyR') reload();
    keys[e.code] = true;
  }
  function onKeyUp(e) { keys[e.code] = false; }

  function applyMovement(dt) {
    const speedWalk = 6;
    const speedRun = 9;
    // forward/back corrected: W moves forward (negative Z in Three)
    const forward = (keys['KeyW'] ? -1 : 0) + (keys['KeyS'] ? 1 : 0);
    const side = (keys['KeyA'] ? -1 : 0) + (keys['KeyD'] ? 1 : 0);
    const isRunning = keys['ShiftLeft'] || keys['ShiftRight'];
    const speed = isRunning ? speedRun : speedWalk;

    // normalized direction
    const direction = new THREE.Vector3(side, 0, forward);
    if (direction.length() > 0) direction.normalize();

    const velocityX = direction.x * speed * dt;
    const velocityZ = direction.z * speed * dt;

    controls.getObject().translateX(velocityX);
    controls.getObject().translateZ(velocityZ);

    // gravity
    velocity.y -= 9.8 * dt;
    controls.getObject().position.y += velocity.y * dt;
    if (controls.getObject().position.y < 1.6) {
      velocity.y = 0;
      controls.getObject().position.y = 1.6;
      canJump = true;
    }
    if (keys['Space'] && canJump) {
      velocity.y = 5; canJump = false;
    }
  }

  // SHOOT: pistol recoil applied to pistolModel; fallback to melee when no ammo
  function shoot() {
    const now = performance.now();
    if (now - lastAttack < 120) return;
    lastAttack = now;

    // if pistol and no ammo -> auto-melee
    if (localPlayer.weapon === 'pistol' && localPlayer.ammo <= 0) {
      localPlayer.weapon = 'melee';
      updateHUD();
      meleeAttack();
      return;
    }

    if (localPlayer.weapon === 'pistol') {
      localPlayer.ammo--;
      updateHUD();
      if (audioCtx && gunBuffer) playBuffer(gunBuffer);

      // recoil on weapon (no camera rotation)
      if (pistolModel) {
        pistolModel.rotation.x = Math.max(pistolModel.rotation.x - 0.15, -0.5);
      }

      const ray = new THREE.Raycaster();
      ray.setFromCamera({x:0,y:0}, camera);
      const allParts = [];
      Object.values(zombieObjects).forEach(z => z.children.forEach(c => allParts.push(c)));
      const hits = ray.intersectObjects(allParts, false);
      if (hits.length) {
        const hit = hits[0];
        let parent = hit.object.parent;
        const zid = Object.keys(zombieObjects).find(k=>zombieObjects[k]===parent);
        if (zid) {
          damageZombie(zid, 35);
          flashCrosshair();
        }
        if (audioCtx && hitBuffer) playBuffer(hitBuffer);
      }
    } else {
      meleeAttack();
    }
  }

  function meleeAttack() {
    const pPos = new THREE.Vector3();
    controls.getObject().getWorldPosition(pPos);
    let nearest = null; let nd = Infinity;
    Object.entries(zombieObjects).forEach(([id, obj]) => {
      const d = obj.position.distanceTo(pPos);
      if (d < 2.2 && d < nd) { nearest = id; nd = d; }
    });
    if (nearest) {
      damageZombie(nearest, 70);
      if (audioCtx && hitBuffer) playBuffer(hitBuffer);
    }
  }

  function damageZombie(id, dmg) {
    const obj = zombieObjects[id];
    if (!obj) return;
    obj.userData.health -= dmg * localPlayer.damageMultiplier;
    obj.traverse(m => { if (m.material && m.material.emissive) m.material.emissive.setHex(0x442222); });
    setTimeout(()=>{ obj.traverse(m => { if (m.material && m.material.emissive) m.material.emissive.setHex(0x000000); }); }, 120);
    if (obj.userData.health <= 0) {
      if (audioCtx && deathBuffer) playBuffer(deathBuffer);
      localPlayer.score += 100;
      scoreEl.textContent = localPlayer.score;
      const idobj = obj;
      const start = performance.now();
      const duration = 450;
      (function anim() {
        const t = (performance.now()-start)/duration;
        if (t < 1) {
          const scale = 1 - t;
          idobj.scale.setScalar(scale);
          requestAnimationFrame(anim);
        } else {
          if (Math.random() < 0.18) spawnAmmoPackAt(idobj.position);
          if (Math.random() < 0.12) spawnHealthPack(idobj.position);
          // dispose resources
          idobj.traverse(m => {
            if (m.geometry) m.geometry.dispose();
            if (m.material) { if (Array.isArray(m.material)) m.material.forEach(mt=>mt.dispose()); else m.material.dispose(); }
          });
          scene.remove(idobj);
          delete zombieObjects[id]; delete zombies[id];
        }
      })();
    }
  }

  function playerDied() {
    if (!gameActive) return;
    gameActive = false;
    try { controls.unlock(); } catch(e){}
    crosshair.style.display = 'none';
    finalScoreEl.textContent = 'Pontuação final: ' + localPlayer.score;
    reportEl.textContent = `O sobrevivente ${localPlayer.name} eliminou ${Math.floor(localPlayer.score/100)} zumbis antes de cair.`;
    gameOverModal.classList.remove('hidden');
  }

  function updateUI() {
    healthBar.style.width = Math.max(0, localPlayer.health) + '%';
    scoreEl.textContent = localPlayer.score;
    if (localPlayer.damageMultiplier > 1) powerupEl.classList.remove('hidden'); else powerupEl.classList.add('hidden');
    updateHUD();
  }
  function updateHUD() {
    ammoEl.textContent = localPlayer.ammo;
    weaponNameEl.textContent = localPlayer.weapon === 'pistol' ? 'Pistola' : 'Melee';
    magCapEl.textContent = localPlayer.magCap;
  }

  function switchWeapon() {
    if (localPlayer.weapon === 'melee') {
      localPlayer.weapon='pistol';
      localPlayer.magCap = 12;
      localPlayer.ammo = Math.max(localPlayer.ammo, 6);
    } else {
      localPlayer.weapon='melee';
    }
    updateHUD();
  }

  function reload() {
    if (localPlayer.weapon !== 'pistol') return;
    localPlayer.ammo = localPlayer.magCap;
    updateHUD();
  }

  function interactChest() {
    localPlayer.damageMultiplier = 2.0;
    setTimeout(()=>{ localPlayer.damageMultiplier = 1.0; }, 20000);
  }

  // spawn a generic powerup (double damage)
  function spawnPowerup() {
    const pos = localPlayer.position.clone();
    pos.x += (Math.random()-0.5)*8; pos.z += (Math.random()-0.5)*8;
    const geo = new THREE.SphereGeometry(0.35,8,8);
    const mat = new THREE.MeshStandardMaterial({color:0x3bff9a, emissive:0x0f7f5a});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(pos.x, 0.6, pos.z);
    mesh.userData = { type: 'doubleDamage', ttl: Date.now() + 20000 };
    scene.add(mesh);
    (function check() {
      if (!mesh.parent) return;
      const dist = mesh.position.distanceTo(localPlayer.position);
      if (dist < 2) {
        localPlayer.damageMultiplier = 2.0;
        setTimeout(()=>{ localPlayer.damageMultiplier = 1.0; }, 20000);
        scene.remove(mesh);
        return;
      }
      if (Date.now() > mesh.userData.ttl) { scene.remove(mesh); return; }
      requestAnimationFrame(check);
    })();
  }

  // spawn ammo pack near a position or player
  function spawnAmmoPackAt(pos) {
    const p = pos ? pos.clone() : localPlayer.position.clone();
    p.x += (Math.random()-0.5)*1.5; p.z += (Math.random()-0.5)*1.5;
    const geo = new THREE.BoxGeometry(0.5,0.25,0.8);
    const mat = new THREE.MeshStandardMaterial({color:0x3b82f6, emissive:0x1a4fb0});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(p.x, 0.5, p.z);
    mesh.userData = { type: 'ammo', value: 6, ttl: Date.now() + 45000 };
    scene.add(mesh);
    (function check() {
      if (!mesh.parent) return;
      const dist = mesh.position.distanceTo(localPlayer.position);
      if (dist < 2) {
        localPlayer.ammo = Math.min(localPlayer.magCap, localPlayer.ammo + mesh.userData.value);
        updateHUD();
        scene.remove(mesh);
        return;
      }
      if (Date.now() > mesh.userData.ttl) { scene.remove(mesh); return; }
      requestAnimationFrame(check);
    })();
  }
  function spawnAmmoPackNearPlayer() { spawnAmmoPackAt(null); }

  function spawnHealthPack(atPos) {
    const pos = atPos ? atPos.clone() : localPlayer.position.clone();
    pos.x += (Math.random()-0.5)*4; pos.z += (Math.random()-0.5)*4;
    const geo = new THREE.BoxGeometry(0.6,0.35,0.6);
    const mat = new THREE.MeshStandardMaterial({color:0xff6666, emissive:0x331111});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(pos.x, 0.5, pos.z);
    mesh.userData = { type: 'health', ttl: Date.now() + 30000 };
    scene.add(mesh);
    (function check() {
      if (!mesh.parent) return;
      const dist = mesh.position.distanceTo(localPlayer.position);
      if (dist < 2) {
        localPlayer.health = Math.min(100, localPlayer.health + 40);
        scene.remove(mesh);
        return;
      }
      if (Date.now() > mesh.userData.ttl) { scene.remove(mesh); return; }
      requestAnimationFrame(check);
    })();
  }

  function flashCrosshair() {
    const old = crosshair.style.transform;
    crosshair.style.transform = 'translate(-50%,-50%) scale(0.8)';
    setTimeout(()=>{ crosshair.style.transform = old; }, 90);
  }

  function triggerHitFlash() {
    hitFlash.style.opacity = '1';
    setTimeout(()=>{ hitFlash.style.opacity = '0'; }, 120);
  }

  function playEmptyClick() {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type='triangle'; o.frequency.value = 220;
    g.gain.value = 0.02;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); setTimeout(()=>{ o.stop(); }, 80);
  }

  //
  // Audio helpers
  //
  function makeGunShotBuffer() {
    if (!audioCtx) return null;
    const ctx = audioCtx;
    const b = ctx.createBuffer(1, ctx.sampleRate*0.18, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/2000);
    return b;
  }
  function makeHitBuffer() {
    if (!audioCtx) return null;
    const ctx = audioCtx;
    const b = ctx.createBuffer(1, ctx.sampleRate*0.12, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i] = Math.sin(i*0.03) * Math.exp(-i/1200) * (Math.random()*0.6+0.2);
    return b;
  }
  function makeDeathBuffer() {
    if (!audioCtx) return null;
    const ctx = audioCtx;
    const b = ctx.createBuffer(1, ctx.sampleRate*0.36, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i] = Math.sin(i*0.008) * Math.exp(-i/3000) * (Math.random()*0.5+0.3);
    return b;
  }
  function playBuffer(buffer) {
    if (!audioCtx || !buffer) return;
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.connect(audioCtx.destination);
    src.start();
  }

  //
  // procedural zombie skin generator using canvas -> texture
  //
  function generateZombieSkin(seed=0) {
    const size = 512;
    const cvs = document.createElement('canvas');
    cvs.width = cvs.height = size;
    const ctx = cvs.getContext('2d');
    const base = `hsl(${Math.floor(80 + Math.random()*40)}, ${20+Math.random()*30}%, ${20+Math.random()*30}%)`;
    ctx.fillStyle = base; ctx.fillRect(0,0,size,size);
    for (let i=0;i<40;i++){
      ctx.fillStyle = `rgba(${50+Math.random()*90}, ${10+Math.random()*90}, ${10+Math.random()*80}, ${0.08+Math.random()*0.28})`;
      const w = 20 + Math.random()*140;
      const h = 20 + Math.random()*140;
      ctx.beginPath();
      ctx.ellipse(Math.random()*size, Math.random()*size, w, h, Math.random()*Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.lineWidth = 6;
    for (let i=0;i<6;i++){
      ctx.strokeStyle = `rgba(${80+Math.random()*80},${80+Math.random()*80},${80+Math.random()*60},${0.06})`;
      ctx.beginPath();
      ctx.moveTo(Math.random()*size, Math.random()*size);
      ctx.lineTo(Math.random()*size, Math.random()*size);
      ctx.stroke();
    }
    for (let s=0;s<120;s++){
      ctx.strokeStyle = `rgba(120,40,30,${0.1+Math.random()*0.2})`;
      ctx.beginPath();
      ctx.moveTo(Math.random()*size, Math.random()*size);
      ctx.lineTo(Math.random()*size, Math.random()*size);
      ctx.stroke();
    }
    const tex = new THREE.CanvasTexture(cvs);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(1,1);
    return tex;
  }

  function createPistolModel() {
    const group = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({color:0x111111, roughness:0.6});
    const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.06,0.4), mat);
    const grip = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.05,0.25), mat);
    grip.position.set(0,-0.08, -0.05);
    barrel.position.set(0, -0.02, -0.25);
    group.add(barrel, grip);
    return group;
  }

  // download helper (I can create and upload ZIP if you re-authorize)
  document.getElementById('download').addEventListener('click', () => {
    alert('Se quiser o ZIP com este projeto, responda "gera o zip" ou autorize o commit com "commita".');
  });

</script>
</body>
</html>
