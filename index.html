<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Zombie Survival 3D — Enhanced</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap" rel="stylesheet">
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16'%3E%3Crect width='16' height='16' fill='%23000'/%3E%3C/svg%3E">
<style>
  :root { --accent: #ff3b3b; --muted: #bfbfbf; --bg: #020205; }
  html,body{height:100%;margin:0;font-family:'Chakra Petch',sans-serif;background:linear-gradient(180deg,#08060a 0%, #1b1a1f 100%); color: #e6e6e6;}
  #game-container{width:100vw;height:100vh;overflow:hidden;position:relative;}
  .hud{position:fixed;left:16px;top:16px;z-index:30;background:linear-gradient(180deg,rgba(10,10,10,0.6),rgba(10,10,10,0.3));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);}
  .hud .bar{height:12px;background:#222;border-radius:8px;overflow:hidden}
  .hud .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#ffb7b7);width:100%}
  .center-hud{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;z-index:30;background:rgba(0,0,0,0.45);padding:10px 18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);}
  .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(0,0,0,0.7),rgba(0,0,0,0.85));z-index:40}
  .card{background:linear-gradient(180deg,#0f0f12,#17171b);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);width:min(760px,95%);}
  #crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:10px;height:10px;border-radius:50%;z-index:35;mix-blend-mode:screen;pointer-events:none;opacity:0.9}
  #crosshair::after{content:'';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:2px;height:2px;background:var(--accent);box-shadow:0 0 8px var(--accent)}
  button.btn{background:var(--accent);color:white;padding:10px 14px;border-radius:8px;border:none;cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  .hidden{display:none!important}
  #hit-flash{position:fixed;inset:0;background:rgba(255,0,0,0.06);z-index:50;pointer-events:none;opacity:0;transition:opacity 160ms}
  #mobile-fire{position:fixed;right:18px;bottom:24px;background:rgba(0,0,0,0.45);padding:18px;border-radius:50%;z-index:60;color:white;display:none}
  #ammo { font-weight:700; margin-left:8px; }
</style>
</head>
<body>
<div id="game-container"></div>
<div id="crosshair"></div>
<div id="hit-flash"></div>
<button id="mobile-fire">FIRE</button>

<div class="hud" id="left-hud">
  <div style="display:flex;gap:12px;align-items:center;">
    <div>
      <div class="small">VIDA</div>
      <div class="bar" style="width:160px"><i id="health-bar" style="width:100%"></i></div>
    </div>
    <div style="min-width:130px">
      <div class="small">PONTOS</div>
      <div id="score" style="font-weight:700;font-size:18px">0</div>
    </div>
    <div style="min-width:180px">
      <div class="small">ARMA <span id="weapon-name" style="font-weight:700">Pistola</span></div>
      <div class="small">MUNIÇÃO: <span id="ammo">12</span>/<span id="mag-cap">12</span></div>
    </div>
  </div>
</div>

<div class="center-hud hidden" id="powerup">DANO DUPLO ATIVO</div>

<div id="lobby" class="modal">
  <div class="card">
    <h1 style="font-size:32px;color:var(--accent);margin:0 0 8px 0">Zombie Survival 3D — Enhanced</h1>
    <p class="small">Modo híbrido: suporta <strong>offline</strong> (sem Firebase) e <strong>online</strong> com Firebase se você fornecer a configuração. Skins procedurais, luzes, som e gameplay finalizado.</p>
    <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap;">
      <input id="name" class="input" placeholder="Seu nome" style="flex:1;padding:10px;border-radius:8px;background:#111;border:1px solid rgba(255,255,255,0.03);color:white" />
      <select id="mode" style="padding:10px;border-radius:8px;background:#111;border:1px solid rgba(255,255,255,0.03);color:white">
        <option value="offline">Offline (local)</option>
        <option value="online">Online (Firebase) — opcional</option>
      </select>
      <button id="start" class="btn">Iniciar Jogo</button>
    </div>
    <div style="margin-top:10px" class="small">Dica: se escolher <em>Online</em>, abra <code>index.html</code> e defina a variável <code>FIREBASE_CONFIG</code> com seu objeto de configuração (veja README).</div>
  </div>
</div>

<div id="game-over" class="modal hidden">
  <div class="card" style="text-align:center;">
    <h2 style="color:var(--accent);font-size:28px">Você morreu</h2>
    <p id="final-score" style="font-weight:700;font-size:20px">0</p>
    <div style="display:flex;gap:10px;margin-top:12px">
      <button id="restart" class="btn">Jogar Novamente</button>
      <button id="download" class="btn" style="background:#3b82f6">Baixar ZIP</button>
    </div>
    <p class="small" style="margin-top:8px">Gerado localmente: dicas e relatório final disponíveis.</p>
    <div style="margin-top:10px" id="report" class="small"></div>
  </div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { PointerLockControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js";
  import { ZombieManager } from './modules/zombies.js';
  import { createEnvironment, spawnPack } from './modules/environment.js';

  const FIREBASE_CONFIG = null;

  const container = document.getElementById('game-container');
  const lobby = document.getElementById('lobby');
  const startBtn = document.getElementById('start');
  const nameInput = document.getElementById('name');
  const modeSelect = document.getElementById('mode');
  const crosshair = document.getElementById('crosshair');
  const gameOverModal = document.getElementById('game-over');
  const restartBtn = document.getElementById('restart');
  const scoreEl = document.getElementById('score');
  const healthBar = document.getElementById('health-bar');
  const powerupEl = document.getElementById('powerup');
  const finalScoreEl = document.getElementById('final-score');
  const reportEl = document.getElementById('report');
  const hitFlash = document.getElementById('hit-flash');
  const mobileFire = document.getElementById('mobile-fire');
  const ammoEl = document.getElementById('ammo');
  const weaponNameEl = document.getElementById('weapon-name');
  const magCapEl = document.getElementById('mag-cap');

  let scene, camera, renderer, clock, controls;
  let localPlayer = { name: 'Player', health: 100, score: 0, damageMultiplier: 1, isAlive: true, position: new THREE.Vector3(), weapon: 'pistol', ammo: 12, magCap: 12 };
  let zombieManager;
  let gameActive = false;
  let lastSpawn = 0;
  let lastAttack = 0;
  let audioCtx;
  let gunBuffer, hitBuffer, deathBuffer;
  let keys = {};
  let velocity = new THREE.Vector3();
  let canJump = true;
  const MAX_ZOMBIES = 60;
  let weaponMesh = null; // pistol model reference
  let skyMesh = null;

  init();

  function init() {
    // renderer + scene
    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0c0b0d, 0.0025);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(0,1.6,0);

    clock = new THREE.Clock();

    // lights
    const hemi = new THREE.HemisphereLight(0x8a7f7a, 0x101014, 0.8);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffcc88, 1.0);
    dir.position.set(-30,40,20);
    dir.castShadow = true;
    dir.shadow.camera.left = -80; dir.shadow.camera.right = 80; dir.shadow.camera.top = 80; dir.shadow.camera.bottom = -80;
    dir.shadow.mapSize.set(2048,2048);
    scene.add(dir);

    // ground
    const groundMat = new THREE.MeshStandardMaterial({color:0x222222, roughness:0.7, metalness:0.05});
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // sky (procedural gradient)
    createSky();

    // environment (lampposts/crates)
    createEnvironment(scene, 20);

    // zombie manager
    zombieManager = new ZombieManager(scene, { maxZombies: MAX_ZOMBIES });
    zombieManager.init();

    // controls
    controls = new PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());

    // player weapon (store mesh for recoil)
    weaponMesh = createPistolModel();
    camera.add(weaponMesh);
    weaponMesh.position.set(0.25,-0.3,-0.6);

    // pointer lock interactions
    document.addEventListener('click', (ev) => {
      if (!gameActive) return;
      if (!controls.isLocked) controls.lock();
    });

    // input and UI
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', restartGame);
    window.addEventListener('resize', onResize);
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);
    window.addEventListener('mousedown', onMouseDown);
    mobileFire.addEventListener('touchstart', (e)=>{ e.preventDefault(); onMobileFire(); }, {passive:false});
    mobileFire.addEventListener('mousedown', onMobileFire);

    // audio
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){ audioCtx = null; }
    window.audioCtx = audioCtx;
    if (audioCtx) {
      gunBuffer = makeGunShotBuffer();
      hitBuffer = makeHitBuffer();
      deathBuffer = makeDeathBuffer();
    }

    animate();
    updateHUD();
    checkMobile();
  }

  function createSky() {
    const size = 1024;
    const cvs = document.createElement('canvas'); cvs.width = cvs.height = size;
    const ctx = cvs.getContext('2d');
    // gradient sky
    const g = ctx.createLinearGradient(0,0,0,size);
    g.addColorStop(0, '#071227'); // top
    g.addColorStop(0.5, '#0b1020');
    g.addColorStop(1, '#101217');
    ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
    // faint clouds
    ctx.globalAlpha = 0.06;
    for (let i=0;i<80;i++){
      ctx.fillStyle = `rgba(255,255,255,${0.02+Math.random()*0.06})`;
      ctx.beginPath();
      ctx.ellipse(Math.random()*size, Math.random()*size*0.7, 100+Math.random()*250, 30+Math.random()*80, Math.random()*Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
    const tex = new THREE.CanvasTexture(cvs);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(6,3);
    const mat = new THREE.MeshBasicMaterial({map: tex, side: THREE.BackSide});
    const sphere = new THREE.Mesh(new THREE.SphereGeometry(900, 32, 32), mat);
    sphere.rotation.x = Math.PI; sphere.renderOrder = 0;
    scene.add(sphere);
    skyMesh = sphere;
  }

  function checkMobile() {
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    if (isMobile) {
      mobileFire.style.display = 'block';
    }
  }

  function startGame() {
    localPlayer.name = nameInput.value.trim() || 'Sobrevivente';
    lobby.classList.add('hidden');
    gameActive = true;
    localPlayer.health = 100; localPlayer.score = 0; localPlayer.isAlive = true;
    localPlayer.weapon = 'pistol'; localPlayer.magCap = 12; localPlayer.ammo = 12;
    scoreEl.textContent = '0'; healthBar.style.width = '100%';
    crosshair.style.display = 'block';
    try { controls.lock(); } catch(e){}
    lastSpawn = Date.now();
  }

  function restartGame() {
    gameOverModal.classList.add('hidden');
    // clear zombies via manager
    Object.keys(zombieManager.zombies).forEach(id => zombieManager._disposeZombie(id));
    startGame();
  }

  function onResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, clock.getDelta());
    if (gameActive) {
      applyMovement(dt);
      hostTick(dt);
      // update zombies via manager
      const pPos = new THREE.Vector3();
      controls.getObject().getWorldPosition(pPos);
      pPos.score = localPlayer.score;
      zombieManager.update(dt, pPos, ({damage,id})=>{
        localPlayer.health -= damage;
        triggerHitFlash();
        if (localPlayer.health <= 0) playerDied();
      });
      handleCollisions();
      updateUI();
    }
    // smooth weapon return (recoil recovery)
    if (weaponMesh) {
      weaponMesh.position.z += ( -0.6 - weaponMesh.position.z ) * 0.18; // return toward -0.6
      weaponMesh.rotation.x += (0 - weaponMesh.rotation.x) * 0.12;
    }
    renderer.render(scene, camera);
  }

  function hostTick(dt) {
    if (Date.now() - lastSpawn > Math.max(700, 2200 - localPlayer.score/15)) {
      lastSpawn = Date.now();
      zombieManager.spawnRandom();
    }
    // occasional powerup spawn
    if (Math.random() < 0.0009) spawnPack(scene, Math.random()<0.5?'ammo':'health', null, (ud)=>{
      if (ud.type==='ammo') { localPlayer.ammo = Math.min(localPlayer.magCap, localPlayer.ammo + ud.value); updateHUD(); }
      if (ud.type==='health') { localPlayer.health = Math.min(100, localPlayer.health + ud.value); updateUI(); }
    });
  }

  function handleCollisions() {}

  function onMouseDown(e) {
    if (!gameActive) return;
    if (e.button === 0) shoot();
  }
  function onMobileFire() { if (!gameActive) return; shoot(); }

  function onKeyDown(e) {
    if (e.code === 'KeyQ') switchWeapon();
    if (e.code === 'KeyE') interactChest();
    if (e.code === 'KeyR') reload();
    keys[e.code] = true;
  }
  function onKeyUp(e) { keys[e.code] = false; }

  function applyMovement(dt) {
    const speedWalk = 6;
    const speedRun = 9;
    const forward = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0);
    const side = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0);
    const isRunning = keys['ShiftLeft'] || keys['ShiftRight'];
    const speed = isRunning ? speedRun : speedWalk;
    controls.getObject().translateX(side * speed * dt);
    controls.getObject().translateZ(forward * speed * dt);
    velocity.y -= 9.8 * dt;
    controls.getObject().position.y += velocity.y * dt;
    if (controls.getObject().position.y < 1.6) {
      velocity.y = 0; controls.getObject().position.y = 1.6; canJump = true;
    }
    if (keys['Space'] && canJump) { velocity.y = 5; canJump = false; }
  }

  // SHOOT: uses weaponMesh recoil; fallback to melee when no ammo
  function shoot() {
    const now = performance.now();
    if (now - lastAttack < 120) return;
    lastAttack = now;
    if (localPlayer.weapon === 'pistol') {
      if (localPlayer.ammo <= 0) {
        // auto-switch to melee if no ammo
        localPlayer.weapon = 'melee';
        updateHUD();
        meleeAttack();
        return;
      }
      localPlayer.ammo--;
      updateHUD();
      if (audioCtx && gunBuffer) playBuffer(gunBuffer);
      // recoil: push weapon forward and tilt a bit
      if (weaponMesh) { weaponMesh.position.z = -0.45; weaponMesh.rotation.x = -0.06; }
      // shoot raycast
      const ray = new THREE.Raycaster();
      ray.setFromCamera({x:0,y:0}, camera);
      const allParts = [];
      Object.values(zombieManager.zombies).forEach(z => z.children.forEach(c => allParts.push(c)));
      const hits = ray.intersectObjects(allParts, false);
      if (hits.length) {
        const hit = hits[0];
        const parent = hit.object.parent;
        const zid = Object.keys(zombieManager.zombies).find(k => zombieManager.zombies[k] === parent);
        if (zid) {
          const res = zombieManager.damage(zid, 35);
          if (res && res.dropped && res.pos) {
            spawnPack(scene, Math.random()<0.6?'ammo':'health', res.pos, (ud)=>{
              if (ud.type==='ammo') { localPlayer.ammo = Math.min(localPlayer.magCap, localPlayer.ammo + ud.value); updateHUD(); }
              if (ud.type==='health') { localPlayer.health = Math.min(100, localPlayer.health + ud.value); updateUI(); }
            });
          }
        }
        if (audioCtx && hitBuffer) playBuffer(hitBuffer);
      }
    } else {
      // melee weapon firing
      meleeAttack();
    }
  }

  function meleeAttack() {
    // simple close-range hit
    const pPos = new THREE.Vector3();
    controls.getObject().getWorldPosition(pPos);
    let nearest = null; let nd = Infinity;
    Object.entries(zombieManager.zombies).forEach(([id, obj]) => {
      const d = obj.position.distanceTo(pPos);
      if (d < 2.2 && d < nd) { nearest = id; nd = d; }
    });
    if (nearest) {
      const res = zombieManager.damage(nearest, 70, 0.25);
      if (audioCtx && hitBuffer) playBuffer(hitBuffer);
      if (res && res.dropped && res.pos) {
        spawnPack(scene, Math.random()<0.6?'ammo':'health', res.pos, (ud)=>{
          if (ud.type==='ammo') { localPlayer.ammo = Math.min(localPlayer.magCap, localPlayer.ammo + ud.value); updateHUD(); }
          if (ud.type==='health') { localPlayer.health = Math.min(100, localPlayer.health + ud.value); updateUI(); }
        });
      }
    }
  }

  function damageZombie(id, dmg) {
    // unused: logic delegated to manager
    return zombieManager.damage(id, dmg);
  }

  function switchWeapon() {
    if (localPlayer.weapon === 'melee') {
      localPlayer.weapon='pistol';
      localPlayer.magCap = 12;
      localPlayer.ammo = Math.max(localPlayer.ammo, 6);
    } else {
      localPlayer.weapon='melee';
    }
    updateHUD();
  }

  function reload() {
    if (localPlayer.weapon !== 'pistol') return;
    localPlayer.ammo = localPlayer.magCap;
    updateHUD();
  }

  function interactChest() {
    localPlayer.damageMultiplier = 2.0;
    setTimeout(()=>{ localPlayer.damageMultiplier = 1.0; }, 20000);
  }

  function playerDied() {
    if (!gameActive) return;
    gameActive = false;
    try { controls.unlock(); } catch(e){}
    crosshair.style.display = 'none';
    finalScoreEl.textContent = 'Pontuação final: ' + localPlayer.score;
    reportEl.textContent = `O sobrevivente ${localPlayer.name} eliminou ${Math.floor(localPlayer.score/100)} zumbis antes de cair.`;
    gameOverModal.classList.remove('hidden');
  }

  function updateUI() {
    healthBar.style.width = Math.max(0, localPlayer.health) + '%';
    scoreEl.textContent = localPlayer.score;
    if (localPlayer.damageMultiplier > 1) powerupEl.classList.remove('hidden'); else powerupEl.classList.add('hidden');
    updateHUD();
  }
  function updateHUD() {
    ammoEl.textContent = localPlayer.ammo;
    weaponNameEl.textContent = localPlayer.weapon === 'pistol' ? 'Pistola' : 'Melee';
    magCapEl.textContent = localPlayer.magCap;
  }

  function flashCrosshair() {
    const old = crosshair.style.transform;
    crosshair.style.transform = 'translate(-50%,-50%) scale(0.8)';
    setTimeout(()=>{ crosshair.style.transform = old; }, 90);
  }
  function triggerHitFlash() {
    hitFlash.style.opacity = '1';
    setTimeout(()=>{ hitFlash.style.opacity = '0'; }, 120);
  }

  function playEmptyClick() {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type='triangle'; o.frequency.value = 220;
    g.gain.value = 0.02;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); setTimeout(()=>{ o.stop(); }, 80);
  }

  // audio helpers
  function makeGunShotBuffer() {
    const ctx = audioCtx;
    const b = ctx.createBuffer(1, ctx.sampleRate*0.18, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/2000);
    return b;
  }
  function makeHitBuffer() {
    const ctx = audioCtx;
    const b = ctx.createBuffer(1, ctx.sampleRate*0.12, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i] = Math.sin(i*0.03) * Math.exp(-i/1200) * (Math.random()*0.6+0.2);
    return b;
  }
  function makeDeathBuffer() {
    const ctx = audioCtx;
    const b = ctx.createBuffer(1, ctx.sampleRate*0.36, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i] = Math.sin(i*0.008) * Math.exp(-i/3000) * (Math.random()*0.5+0.3);
    return b;
  }
  function playBuffer(buffer) {
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.connect(audioCtx.destination);
    src.start();
  }

  // pistol model for recoil
  function createPistolModel() {
    const group = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({color:0x111111, roughness:0.6});
    const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.06,0.4), mat);
    const grip = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.05,0.25), mat);
    grip.position.set(0,-0.08, -0.05);
    barrel.position.set(0, -0.02, -0.25);
    group.add(barrel, grip);
    return group;
  }

  // download helper
  document.getElementById('download').addEventListener('click', () => {
    alert('Se quiser o ZIP com este projeto, autorize que eu faça o commit ao repositório respondendo "commita".');
  });

</script>

<!-- Start overlay + debug utilities -->
<script>
(function () {
  function ensure() {
    const lobby = document.getElementById('lobby');
    const startBtn = document.getElementById('start');
    if (!lobby || !startBtn) { setTimeout(ensure, 200); return; }
    if (!document.getElementById('start-overlay')) {
      const overlay = document.createElement('div');
      overlay.id = 'start-overlay';
      overlay.style = [
        'position:fixed',
        'inset:0',
        'display:flex',
        'align-items:center',
        'justify-content:center',
        'background:linear-gradient(180deg,rgba(0,0,0,0.6),rgba(0,0,0,0.75))',
        'z-index:60',
        'backdrop-filter: blur(2px)'
      ].join(';');
      const btn = document.createElement('button');
      btn.textContent = 'Clique para Começar';
      btn.style = 'padding:16px 22px;border-radius:10px;background:#ff3b3b;color:white;border:none;font-size:18px;cursor:pointer';
      btn.id = 'start-overlay-btn';
      overlay.appendChild(btn);
      document.body.appendChild(overlay);

      btn.addEventListener('click', async function () {
        overlay.remove();
        if (window.audioCtx && window.audioCtx.state === 'suspended') {
          try { await window.audioCtx.resume(); } catch(e) { console.warn('audio resume failed', e); }
        }
        if (startBtn) startBtn.click();
        try {
          const canvas = document.querySelector('canvas');
          if (canvas && canvas.requestPointerLock) {
            canvas.requestPointerLock();
          } else if (typeof document.body.requestPointerLock === 'function') {
            document.body.requestPointerLock();
          }
        } catch(e){ console.warn('pointer lock request failed', e); }
      });
    }

    window.__game_debug = {
      clickStart: function(){ document.getElementById('start')?.click(); },
      hideLobby: function(){ document.getElementById('lobby')?.classList.add('hidden'); },
      showLobby: function(){ document.getElementById('lobby')?.classList.remove('hidden'); },
      spawnZ: function(){ window.zombieManager?.spawnRandom(); },
      listZ: function(){ console.log('zombies:', Object.keys(window.zombieManager?.zombies||{})); }
    };
    console.log('Start overlay and debug utilities installed. Use __game_debug.clickStart() to trigger start programmatically.');
  }
  ensure();
})();
</script>

</body>
</html>
