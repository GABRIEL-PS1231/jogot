<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Jogo Zumbi - Versão Melhorada</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#0b0b0f;color:#ddd;font-family:Inter, Arial;}
    #container{width:100%;height:100%;position:relative;}
    #overlayUI{
      position:absolute;left:12px;bottom:12px;z-index:10;color:#fff;
      background:linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.45));
      padding:8px;border-radius:8px;font-size:14px;
      backdrop-filter: blur(4px);
    }
    .btn{background:rgba(255,255,255,0.06);padding:6px 10px;border-radius:6px;margin-right:6px;border:1px solid rgba(255,255,255,0.04);cursor:pointer;color:#fff}
    #fps{font-size:12px;opacity:0.85}
    canvas{display:block}
    /* mobile joystick placeholder */
    #joystick{position:absolute;left:12px;bottom:80px;width:120px;height:120px;border-radius:50%;z-index:40;touch-action:none}
    #fireBtn{position:absolute;right:18px;bottom:70px;width:82px;height:82px;border-radius:50%;z-index:40;background:rgba(255,0,0,0.08);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700}
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="overlayUI">
    <span id="fps">FPS: --</span>
    <div style="margin-top:6px">
      <button id="toggleShadows" class="btn">Sombras: ON</button>
      <button id="spawnZombieBtn" class="btn">Spawn Zumbi</button>
      <button id="toggleDebug" class="btn">Debug</button>
    </div>
  </div>

  <!-- optional mobile controls -->
  <div id="joystick" aria-hidden="true"></div>
  <div id="fireBtn" aria-hidden="true">ATIRAR</div>

  <!-- three.js e loaders (non-module builds, mais compatíveis com Pages) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/loaders/FBXLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/loaders/MTLLoader.js"></script>

  <script>
  /******************************************************************
   * CONFIG - ajuste aqui se renomear arquivos no repo (case-sensitive)
   ******************************************************************/
  const FILE_GUN_OBJ = 'Gun.obj';
  const FILE_GUN_MTL = 'Gun.mtl';
  const FILE_GUN_PNG = 'Gun.png';
  const FILE_GROUND = 'Sample.png';
  const FILE_ZOMBIE_IDLE = 'idle.fbx';
  const FILE_ZOMBIE_RUN  = 'run.fbx';
  const FILE_ZOMBIE_JUMP = 'jump.fbx';
  // skins (se tiver várias, adicione os nomes exatos)
  const ZOMBIE_SKINS = ['Sample.png']; // fallback para Sample.png
  /******************************************************************/

  // globals
  let scene, camera, renderer, clock, mixers = [], activeMixers = [], controlsData = {};
  let zombieTemplate = null, gunObject = null;
  const zombies = {}; // id -> group
  const container = document.getElementById('container');

  // movement/player state
  const player = {
    pos: new THREE.Vector3(0, 1.2, 4),
    velocity: new THREE.Vector3(),
    speed: 4.5,
    onGround: true,
    yaw: 0
  };

  init();
  animate();

  function init(){
    // scene + camera
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x06060a);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 1.6, 6);
    camera.lookAt(0,1,0);

    // renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // clock
    clock = new THREE.Clock();

    // LIGHTS - mais visibilidade mas ainda sombria
    const amb = new THREE.HemisphereLight(0x8888aa, 0x120b14, 0.6);
    scene.add(amb);

    const dir = new THREE.DirectionalLight(0xfff3d8, 1.0);
    dir.position.set(6, 12, 6);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048,2048);
    dir.shadow.camera.left = -20; dir.shadow.camera.right = 20;
    dir.shadow.camera.top = 20; dir.shadow.camera.bottom = -20;
    dir.shadow.camera.near = 0.5; dir.shadow.camera.far = 60;
    scene.add(dir);

    // rim light pra destacar modelos
    const rim = new THREE.DirectionalLight(0x99bbff, 0.25);
    rim.position.set(-6, 6, -8);
    scene.add(rim);

    // floor
    const floorGeo = new THREE.PlaneGeometry(300,300);
    const loader = new THREE.TextureLoader();
    loader.setCrossOrigin('');
    loader.load(FILE_GROUND, tex => {
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(80,80);
      const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 1, metalness: 0 });
      const floor = new THREE.Mesh(floorGeo, mat);
      floor.rotation.x = -Math.PI/2;
      floor.receiveShadow = true;
      scene.add(floor);
      console.log('Chão carregado:', FILE_GROUND);
    }, undefined, err => {
      console.warn('Falha ao carregar Sample.png (fundo). Verifique nome/path.', err);
      // fallback floor
      const fallback = new THREE.Mesh(floorGeo, new THREE.MeshStandardMaterial({color:0x131316}));
      fallback.rotation.x = -Math.PI/2;
      fallback.receiveShadow = true;
      scene.add(fallback);
    });

    // carregadores
    fbxLoader = new THREE.FBXLoader();
    objLoader = new THREE.OBJLoader();
    mtlLoader = new THREE.MTLLoader();

    // carrega arma
    loadGun();

    // carrega modelo zumbi e animações
    loadZombieTemplate();

    // spawn inicial
    for (let i=0;i<2;i++) spawnZombie();

    // HUD buttons
    document.getElementById('spawnZombieBtn').addEventListener('click', ()=> spawnZombie());
    document.getElementById('toggleShadows').addEventListener('click', toggleShadows);
    document.getElementById('toggleDebug').addEventListener('click', toggleDebug);

    // mobile joystick simple implementation
    setupSimpleJoystick();

    // eventos resize e teclado
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);

    // debug fps
    setInterval(()=> {
      const el = document.getElementById('fps');
      if (!el) return;
      el.innerText = `FPS: ${Math.round(1/Math.max(0.0001, clock.getDelta()))}`;
    },1000);
  }

  /***********************
   * LOADERS & ASSETS
   ***********************/
  let fbxLoader, objLoader, mtlLoader;

  function loadGun(){
    // MTL -> OBJ -> apply texture fix
    mtlLoader.load(FILE_GUN_MTL, materials => {
      materials.preload();
      objLoader.setMaterials(materials);
      objLoader.load(FILE_GUN_OBJ, obj => {
        gunObject = obj;
        gunObject.traverse(c => {
          if (c.isMesh) {
            c.castShadow = true;
            c.receiveShadow = false;
            // tenta forçar textura caso MTL tenha referência pro Gun.png com nome diferente
            if (!c.material.map) {
              const tloader = new THREE.TextureLoader();
              tloader.load(FILE_GUN_PNG, tex => {
                c.material.map = tex;
                c.material.needsUpdate = true;
                console.log('Aplicada textura da arma:', FILE_GUN_PNG);
              }, undefined, err => {
                console.warn('Falha ao carregar textura da arma:', FILE_GUN_PNG, err);
              });
            }
          }
        });
        gunObject.scale.set(0.7,0.7,0.7);
        gunObject.position.set(0.55, -0.4, -0.6); // posicionamento relativo ao player
        camera.add(gunObject);
        scene.add(camera); // garantir que camera esteja em cena
        console.log('Arma carregada:', FILE_GUN_OBJ, FILE_GUN_MTL);
      }, undefined, err => {
        console.error('Falha ao carregar OBJ da arma:', FILE_GUN_OBJ, err);
      });
    }, undefined, err => {
      console.warn('Falha ao carregar MTL:', FILE_GUN_MTL, err);
      // tenta carregar apenas obj sem mtl
      objLoader.load(FILE_GUN_OBJ, obj => {
        gunObject = obj;
        gunObject.traverse(c => { if (c.isMesh) c.castShadow = true; });
        gunObject.scale.set(0.7,0.7,0.7);
        camera.add(gunObject);
        console.log('Arma carregada sem MTL:', FILE_GUN_OBJ);
      }, undefined, errobj => {
        console.error('Falha ao carregar OBJ (fallback):', FILE_GUN_OBJ, errobj);
      });
    });
  }

  // carrega modelo base do zumbi + animações separadas (idle/run/jump)
  function loadZombieTemplate(){
    // carrega um FBX base (idle) e reúne as animações em userData.animations
    fbxLoader.load(FILE_ZOMBIE_IDLE, base => {
      base.traverse(c => { if (c.isMesh) { c.castShadow=true; c.receiveShadow=true; } });
      base.scale.set(0.008,0.008,0.008);
      zombieTemplate = base;
      zombieTemplate.userData = zombieTemplate.userData || {};
      zombieTemplate.userData.animations = zombieTemplate.animations ? zombie.animationsClone = zombieTemplate.animations.slice() : [];
      console.log('Template base do zumbi carregado (idle):', FILE_ZOMBIE_IDLE);
    }, undefined, err => {
      console.warn('Não carregou idle.fbx — zumbi base faltando?', err);
      zombieTemplate = new THREE.Group(); // fallback
    });

    // tentamos carregar animacoes separadas e concatenar
    const animFiles = [FILE_ZOMBIE_IDLE, FILE_ZOMBIE_RUN, FILE_ZOMBIE_JUMP];
    animFiles.forEach(name => {
      fbxLoader.load(name, animObj => {
        if (!zombieTemplate) zombieTemplate = new THREE.Group();
        zombieTemplate.userData = zombieTemplate.userData || {};
        zombieTemplate.userData.animations = zombieTemplate.userData.animations || [];
        if (animObj.animations && animObj.animations.length){
          animObj.animations.forEach(cl => zombieTemplate.userData.animations.push(cl));
          console.log('Animação adicionada do arquivo:', name);
        } else {
          console.warn('Arquivo FBX sem animação:', name);
        }
      }, undefined, err => {
        // não existindo, apenas log
        console.warn('Falha ao carregar animação FBX (talv. não existe):', name, err);
      });
    });

    // tenta pré-carregar skins (texturas)
    const tloader = new THREE.TextureLoader();
    ZOMBIE_SKINS.forEach(s => {
      tloader.load(s, tex => {
        console.log('Skin carregada:', s);
      }, undefined, err => {
        console.warn('Falha ao carregar skin:', s, err);
      });
    });
  }

  /***********************
   * SPAWN ZOMBIE
   ***********************/
  let zombieIdCounter = 0;
  function spawnZombie(pos){
    // cria grupo, instancia visual (clonando template) e adiciona mixer com clip aleatório
    const id = 'z'+(++zombieIdCounter);
    const group = new THREE.Group();
    group.position.copy(pos || new THREE.Vector3((Math.random()-0.5)*10, 0, -6 - Math.random()*6));
    group.rotation.y = Math.random()*Math.PI*2;
    group.scale.set(1,1,1);

    // modelo visual: clone do template (se existir) ou box fallback
    if (zombieTemplate && zombieTemplate.children && zombieTemplate.children.length){
      const clone = cloneFBX(zombieTemplate);
      group.add(clone);
    } else {
      const geo = new THREE.BoxGeometry(0.6,1.6,0.6);
      const mat = new THREE.MeshStandardMaterial({color:0x5b6b4d});
      const m = new THREE.Mesh(geo, mat);
      m.castShadow = true; m.receiveShadow = true;
      m.position.y = 0.8;
      group.add(m);
    }

    // adiciona collider simples
    group.userData = {
      id,
      speed: 1 + Math.random()*0.6,
      hp: 10,
      mixer: null
    };

    // animação: se template tiver clips, cria mixer e play
    if (zombieTemplate && zombieTemplate.userData && Array.isArray(zombieTemplate.userData.animations) && zombieTemplate.userData.animations.length){
      try {
        const mixer = new THREE.AnimationMixer(group);
        const clips = zombieTemplate.userData.animations;
        const clip = clips[Math.floor(Math.random()*clips.length)];
        const action = mixer.clipAction(clip);
        action.timeScale = 1 + (Math.random()-0.5)*0.2;
        action.play();
        group.userData.mixer = mixer;
        activeMixers.push(mixer);
      } catch(e){
        console.warn('Erro ao aplicar animação ao zumbi', e);
      }
    }

    scene.add(group);
    zombies[id] = group;
    console.log('Zumbi spawnado:', id);
    return id;
  }

  // util: clona objeto FBX (trivial, deep clone by scene graph)
  function cloneFBX(source){
    const clone = source.clone(true);
    // clone animations podem estar em userData; mas AnimationMixer será feito por spawnZombie
    return clone;
  }

  /***********************
   * GAME LOOP
   ***********************/
  const tempVec = new THREE.Vector3();
  function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, clock.getDelta());

    // update mixers
    for (let i = activeMixers.length-1; i>=0; i--){
      const m = activeMixers[i];
      if (!m) { activeMixers.splice(i,1); continue; }
      m.update(dt);
    }

    updatePlayer(dt);
    updateZombies(dt);

    renderer.render(scene, camera);
  }

  function updatePlayer(dt){
    // input -> desired velocity
    const forwardVec = new THREE.Vector3();
    camera.getWorldDirection(forwardVec);
    forwardVec.y = 0; forwardVec.normalize();

    // compute right vector (CORREÇÃO: forward x up, não up x forward) -> evita joystick invertido
    const up = new THREE.Vector3(0,1,0);
    const rightVec = new THREE.Vector3().crossVectors(forwardVec, up).normalize();

    const move = new THREE.Vector3();
    if (controlsData.forward) move.add(forwardVec);
    if (controlsData.backward) move.add(forwardVec.clone().negate());
    if (controlsData.left) move.add(rightVec.clone().negate());
    if (controlsData.right) move.add(rightVec);

    if (move.lengthSq()>0.0001) {
      move.normalize();
      // smoothing interpolation for nicer movement
      player.velocity.lerp(move.multiplyScalar(player.speed), 0.2);
    } else {
      player.velocity.lerp(new THREE.Vector3(0,0,0), 0.18);
    }

    // gravity + vertical
    if (!player.onGround) player.velocity.y -= 9.8 * dt;

    // move player
    player.pos.addScaledVector(player.velocity, dt);
    // simple ground collision
    if (player.pos.y < 1.2) { player.pos.y = 1.2; player.onGround = true; player.velocity.y = 0; }

    // set camera relative to player
    camera.position.lerp(new THREE.Vector3(player.pos.x, player.pos.y+0.4, player.pos.z + 0.0), 0.12);
    camera.lookAt(player.pos.x + forwardVec.x*4, player.pos.y+0.4, player.pos.z+forwardVec.z*4);
  }

  function updateZombies(dt){
    // simples AI: andar em direção ao jogador
    Object.keys(zombies).forEach(id => {
      const g = zombies[id];
      if (!g) return;
      tempVec.subVectors(new THREE.Vector3(player.pos.x,0,player.pos.z), new THREE.Vector3(g.position.x,0,g.position.z));
      const dist = tempVec.length();
      if (dist > 0.5) {
        tempVec.normalize();
        g.position.addScaledVector(tempVec, (g.userData.speed || 1) * dt);
        // face player
        g.lookAt(player.pos.x, g.position.y, player.pos.z);
      } else {
        // alcance — diminui HP do player (não implementado full)
        // aqui podemos adicionar som ou ataque
      }
    });
  }

  /***********************
   * INPUT (teclado + mobile joystick)
   ***********************/
  function onKeyDown(e){
    if (e.code === 'KeyW') controlsData.forward = true;
    if (e.code === 'KeyS') controlsData.backward = true;
    if (e.code === 'KeyA') controlsData.left = true;
    if (e.code === 'KeyD') controlsData.right = true;
    if (e.code === 'Space' && player.onGround) { player.velocity.y = 5; player.onGround = false; }
  }
  function onKeyUp(e){
    if (e.code === 'KeyW') controlsData.forward = false;
    if (e.code === 'KeyS') controlsData.backward = false;
    if (e.code === 'KeyA') controlsData.left = false;
    if (e.code === 'KeyD') controlsData.right = false;
  }

  // Simple touch joystick for mobile (lightweight)
  function setupSimpleJoystick(){
    const joy = document.getElementById('joystick');
    const fire = document.getElementById('fireBtn');
    if (!joy || !fire) return;

    let dragging = false;
    let origin = null;

    joy.addEventListener('pointerdown', (ev) => {
      joy.setPointerCapture(ev.pointerId);
      dragging = true;
      origin = {x: ev.clientX, y: ev.clientY};
      joy.style.background = 'rgba(255,255,255,0.03)';
    });
    joy.addEventListener('pointermove', (ev) => {
      if (!dragging) return;
      const dx = ev.clientX - origin.x;
      const dy = ev.clientY - origin.y;
      // map dx/dy -> directional booleans
      controlsData.right = dx > 20;
      controlsData.left = dx < -20;
      controlsData.forward = dy < -20;
      controlsData.backward = dy > 20;
    });
    joy.addEventListener('pointerup', (ev) => {
      dragging = false;
      controlsData.forward = controlsData.backward = controlsData.left = controlsData.right = false;
      joy.style.background = '';
    });

    // fire button quick handler
    fire.addEventListener('pointerdown', ()=> {
      // efeito de tiro simples: pequeno flash e soma de pontos ou spawn bullet
      spawnMuzzleFlash();
    });
  }

  // spawn visual simple (muzzle flash in front of camera)
  function spawnMuzzleFlash(){
    const sGeo = new THREE.PlaneGeometry(0.4,0.4);
    const mat = new THREE.MeshBasicMaterial({color:0xffefce,transparent:true,opacity:0.85,side:THREE.DoubleSide});
    const flash = new THREE.Mesh(sGeo, mat);
    flash.position.copy(camera.position).add(new THREE.Vector3(0, -0.2, -0.8).applyQuaternion(camera.quaternion));
    flash.quaternion.copy(camera.quaternion);
    scene.add(flash);
    setTimeout(()=> scene.remove(flash), 80);
  }

  /***********************
   * UTIL / DEBUG
   ***********************/
  function toggleShadows(){
    renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
    document.getElementById('toggleShadows').innerText = 'Sombras: ' + (renderer.shadowMap.enabled ? 'ON' : 'OFF');
  }
  function toggleDebug(){
    // exemplo simples: adiciona/removes caixas de debug sobre zumbis
    Object.values(zombies).forEach(g => {
      if (!g.userData.boxHelper) {
        const box = new THREE.BoxHelper(g, 0xff0000);
        scene.add(box);
        g.userData.boxHelper = box;
      } else {
        scene.remove(g.userData.boxHelper);
        delete g.userData.boxHelper;
      }
    });
  }

  function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // remover zumbi (dispose mixer)
  function removeZombie(id){
    const g = zombies[id];
    if (!g) return;
    if (g.userData.mixer){
      const idx = activeMixers.indexOf(g.userData.mixer);
      if (idx !== -1) activeMixers.splice(idx,1);
      try { g.userData.mixer.stopAllAction(); } catch(e){}
      delete g.userData.mixer;
    }
    scene.remove(g);
    delete zombies[id];
  }

  // debug console gentle hints
  console.log('Jogo inicializado. Verifique o console Network para 404/CORS em assets (se houver).');
  console.log('Arquivos esperados (case-sensitive):', FILE_GUN_OBJ, FILE_GUN_MTL, FILE_GUN_PNG, FILE_GROUND, FILE_ZOMBIE_IDLE, FILE_ZOMBIE_RUN, FILE_ZOMBIE_JUMP);
  </script>
</body>
</html>